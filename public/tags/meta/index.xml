<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Meta on 清夜无尘の一方天地</title>
    <link>https://wander1ng.com/tags/meta/</link>
    <description>Recent content in Meta on 清夜无尘の一方天地</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <copyright>Copyright © 2019–2024</copyright>
    <lastBuildDate>Fri, 05 Jul 2024 15:35:25 +0800</lastBuildDate>
    
	<atom:link href="https://wander1ng.com/tags/meta/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>常见JavaScript混淆与反混淆</title>
      <link>https://wander1ng.com/post/%E5%B8%B8%E8%A7%81javascript%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/</link>
      <pubDate>Fri, 05 Jul 2024 15:35:25 +0800</pubDate>
      
      <guid>https://wander1ng.com/post/%E5%B8%B8%E8%A7%81javascript%E6%B7%B7%E6%B7%86%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86/</guid>
      <description>&lt;p&gt;JavaScript 混淆（Obfuscation）是指通过一系列技术手段，使 JS 代码变得难以理解和分析，增加代码的复杂性和混淆度，阻碍逆向工程和代码盗用。实际上就是一种保护 JS 代码的手段。JS最早被设计出来就是为了在客户端运行，直接以源码的形式传递给客户端，如果不做处理则完全公开透明，任何人都可以读、分析、复制、盗用，甚至篡改源码与数据，这是网站开发者不愿意看到的。&lt;/p&gt;
&lt;p&gt;压缩工具开发的初衷是减小 JS 文件体积，但 JS 代码经过压缩替换后，其可读性也大大降低，间接起到了保护代码的作用。但是后来主流浏览器的开发者工具都提供了格式化代码的功能，压缩技术所能提供的安全保护收效甚微。于是专门保护 JS 代码的技术：JS 加密和 JS 混淆。&lt;/p&gt;
&lt;h4 id=&#34;常见混淆手段&#34;&gt;常见混淆手段&lt;/h4&gt;
&lt;p&gt;变量名/函数名的替换，将有意义的变量名函数名替换为随机生成的名称&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/*
function calculateArea(radius) {
  return Math.PI * radius * radius;
}
console.log(calculateArea(5));
*/
function _0x2d8f05(_0x4b083b) {
  return Math.PI * _0x4b083b * _0x4b083b;
}
console.log(_0x2d8f05(5));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字符串混淆，将代码中的字符串替换为编码或加密的形式，可以防止字符串被轻易读取。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// console.log(&amp;#34;Hello, world!&amp;#34;);
console.log(&amp;#34;\x48\x65\x6c\x6c\x6f\x2c\x20\x77\x6f\x72\x6c\x64\x21&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;控制流混淆，改变代码的执行顺序或结构。例如，可以使用条件语句和循环语句来替换简单的赋值操作。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/*
let a = 1;
let b = 2;
let c = a + b;
console.log(c);
*/
let a = 1;
let b = 2;
let c;
if (a === 1) {
  if (b === 2) {
    c = a + b;
  }
}
console.log(c);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;花指令，即在源码插入一些不会被执行的代码。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/*
let a = 1;
let b = 2;
let c = a + b;
console.log(c);
*/
let a = 1;
let b = 2;
if (false) {
  console.log(a - b);
}
let c = a + b;
console.log(c);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码转换，将代码转换为等价的，但更难理解的形式。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/*
let a = 1;
let b = 2;
let c = a + b;
console.log(c);
*/
let a = 1;
let b = 2;
let c = a - (-b);
console.log(c);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;常见反调试手段&#34;&gt;常见反调试手段&lt;/h4&gt;
&lt;p&gt;实现防止他人调试、动态分析自己的代码，我们可以预先在代码中做处理，防止用户调试代码。&lt;/p&gt;
&lt;p&gt;无限 debugger。比如写个定时器死循环禁止调试。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var c = new RegExp(&amp;#34;1&amp;#34;);
c.toString = function () {
    alert(&amp;#34;检测到调试&amp;#34;)
    setInterval(function() {
        debugger
    }, 1000);
}
console.log(c);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内存耗尽。更隐蔽的反调试手段，代码运行造成的内存占用会越来越大，很快会使浏览器崩溃。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var startTime = new Date();
debugger;
var endTime = new Date();
var isDev = endTime - startTime &amp;gt; 100;
var stack = [];

if (isDev) {
    while (true) {
        stack.push(this);
        console.log(stack.length, this);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检测函数、对象属性修改。攻击者在调试的时，经常会把防护的函数删除，或者把检测数据对象进行篡改。可以检测函数内容，在原型上设置禁止修改。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;function eval() {
    [native code]
}

window.eval = function(str) {
    console.log(&amp;#34;[native code]&amp;#34;);
};

window.eval = function(str) {
};

window.eval.toString = function() {
    return `function eval() {[native code]}`
};

function hijacked(fun) {
    return &amp;#34;prototype&amp;#34; in fun || fun.toString().replace(/\n|\s/g, &amp;#34;&amp;#34;) != &amp;#34;function&amp;#34; + fun.name + &amp;#34;() {[nativecode]}&amp;#34;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;在线混淆工具&#34;&gt;在线混淆工具&lt;/h4&gt;
&lt;h4 id=&#34;反混淆&#34;&gt;反混淆&lt;/h4&gt;
&lt;p&gt;JS 反混淆（Deobfuscator ）是指对经过混淆处理的代码进行还原和解析，以恢复其可读性。Deobfuscator 可以通过对代码进行静态分析和动态分析等方式来实现。需要注意的是，Obfuscation 只能降低可读性，不能完全避免逆向攻击，而 Deobfuscator 也并不能完全还原混淆过的代码。&lt;/p&gt;
&lt;h4 id=&#34;在线反混淆工具&#34;&gt;在线反混淆工具&lt;/h4&gt;
&lt;p&gt;以及浏览器前端中的Source窗口，配合console.log（）函数非常好用。&lt;/p&gt;
&lt;p&gt;目前的需求是，一段经过混淆的恶意代码，能否直接在前端执行出解混淆后的结果。目前认知来看只有编码类混淆可以，而且存在执行到C2的风险。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://wander1ng.com/about/</link>
      <pubDate>Thu, 04 Jul 2024 22:02:31 +0800</pubDate>
      
      <guid>https://wander1ng.com/about/</guid>
      <description>&lt;p&gt;Cybersecurity Researcher(Focusing on Advanced Persistent Threat)&lt;/p&gt;
&lt;p&gt;Interest: Reading | Photography  | Travel | Wander | Cooking&lt;/p&gt;
&lt;p&gt;WeChat ID: WanderingtotheMoon (どうぞよろしくお願いいたします)&lt;/p&gt;
&lt;p&gt;[不要温和地走进那个良夜]——Dylan Thomas&lt;/p&gt;
&lt;p&gt;[我与我周旋久 宁作我]——《世说新语》&lt;/p&gt;
&lt;p&gt;[去爱去生活去受伤]——《我的阿勒泰》&lt;/p&gt;
&lt;p&gt;[A rolling stone gathers no moss]——Publiius Syrus&lt;/p&gt;
&lt;p&gt;[湖中焉得更有此人！]——张岱&lt;/p&gt;
&lt;p&gt;[身体为了繁衍留下后代，精神为了繁衍留下文字。]——我自己&lt;/p&gt;
&lt;p&gt;[阅读只是在被动接受，你读过什么并不代表你是什么。书写才能定义自我，你所写下的就是你自己。]——我自己&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gensis</title>
      <link>https://wander1ng.com/post/gensis/</link>
      <pubDate>Wed, 19 Jun 2019 02:56:00 +0800</pubDate>
      
      <guid>https://wander1ng.com/post/gensis/</guid>
      <description>&lt;p&gt;Earthquake and Blog&lt;/p&gt;
&lt;p&gt;第一次建博客的那天晚上，人在学校宿舍，遭遇了人生第一次感到恐慌的地震，震级为6.0级，以至于之后的半年常常在半夜惊醒。&lt;/p&gt;
&lt;p&gt;地震这事，大概就和吃云南野生菌中毒一样，没有必要执着于去经历一次，可是经历过一次真的永生难忘&amp;hellip;&lt;/p&gt;
&lt;p&gt;又想到《西游记》中齐天大圣也是从一块灵石降世，这地震大抵也是我的博客第一声“Hello World&amp;quot;引发的天地异象~&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>